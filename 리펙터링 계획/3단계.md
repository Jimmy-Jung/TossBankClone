
# í† ìŠ¤ë±…í¬ í´ë¡  í”„ë¡œì íŠ¸ ë¦¬íŒ©í„°ë§ 3ë‹¨ê³„ ì‹¤í–‰ ê³„íš

## 3ë‹¨ê³„: ì½”ì–´ ëª¨ë“ˆ ì¬êµ¬ì„± (3ì£¼)

### 3-1: Database ëª¨ë“ˆ ë¶„ë¦¬ (1ì£¼)

#### 1-2ì¼ì°¨: DataModule ë¶„ì„ ë° ë¶„ë¦¬ ê³„íš ìˆ˜ë¦½
1. **í˜„ì¬ ë°ì´í„° ì €ì¥ êµ¬ì¡° ë¶„ì„**
   ```bash
   # DataModule ë‚´ ë¡œì»¬ ì €ì¥ì†Œ ê´€ë ¨ ì½”ë“œ ì‹ë³„
   find App/Modules/DataModule -type f -name "*.swift" | xargs grep -l "SwiftData\|CoreData\|UserDefaults\|Keychain"
   ```

2. **ì˜ì¡´ì„± ê·¸ë˜í”„ ë¶„ì„**
   - DataModuleê³¼ ë‹¤ë¥¸ ëª¨ë“ˆ ê°„ì˜ ì˜ì¡´ì„± ì‹ë³„
   - ë¡œì»¬ ë°ì´í„° ì €ì¥ì†Œì— ì˜ì¡´í•˜ëŠ” ì½”ë“œ ê²½ë¡œ í™•ì¸

3. **ë¶„ë¦¬ ê³„íš ìˆ˜ë¦½**
   - ë¶„ë¦¬í•  ì½”ë“œ ëª©ë¡ ì‘ì„±
   - ë§ˆì´ê·¸ë ˆì´ì…˜ ìˆœì„œ ê²°ì •
   - ì˜í–¥ ë°›ëŠ” ëª¨ë“ˆ ì‹ë³„

#### 3-4ì¼ì°¨: SwiftData/CoreData ê´€ë ¨ ì½”ë“œ ë¶„ë¦¬
1. **DatabaseModule ìŠ¤ì¼ˆë ˆí†¤ ìƒì„±**
   ```swift
   // DatabaseModule/Project.swift ìƒì„±
   import ProjectDescription
   
   let project = Project(
       name: "DatabaseModule",
       organizationName: "TossBankClone",
       options: .options(
           automaticSchemesOptions: .disabled
       ),
       packages: [],
       settings: .settings(
           base: [:],
           configurations: [
               .debug(name: "Debug"),
               .release(name: "Release")
           ],
           defaultSettings: .recommended
       ),
       targets: [
           Target(
               name: "DatabaseModule",
               platform: .iOS,
               product: .framework,
               bundleId: "com.tossbankclone.databasemodule",
               deploymentTarget: .iOS(targetVersion: "15.0", devices: [.iphone]),
               infoPlist: .default,
               sources: ["Sources/**"],
               resources: ["Resources/**"],
               dependencies: []
           ),
           Target(
               name: "DatabaseModuleTests",
               platform: .iOS,
               product: .unitTests,
               bundleId: "com.tossbankclone.databasemodule.tests",
               deploymentTarget: .iOS(targetVersion: "15.0", devices: [.iphone]),
               infoPlist: .default,
               sources: ["Tests/**"],
               dependencies: [
                   .target(name: "DatabaseModule")
               ]
           )
       ]
   )
   ```

2. **ì½”ì–´ ë°ì´í„° ê´€ë¦¬ í´ë˜ìŠ¤ ì´ì „**
   - CoreDataManager, SwiftDataManager ë“± í•µì‹¬ í´ë˜ìŠ¤ ì´ì „
   - ìŠ¤í‚¤ë§ˆ ì •ì˜ ë° ë§ˆì´ê·¸ë ˆì´ì…˜ ì½”ë“œ ì´ì „

3. **ë°ì´í„° ì•¡ì„¸ìŠ¤ ë ˆì´ì–´ êµ¬í˜„**
   ```swift
   // DatabaseModule/Sources/Core/DatabaseManager.swift
   import Foundation
   import SwiftData
   
   public protocol DatabaseManagerProtocol {
       func save<T: PersistentModel>(_ item: T) async throws
       func fetch<T: PersistentModel>(_ type: T.Type, predicate: Predicate<T>?) async throws -> [T]
       func delete<T: PersistentModel>(_ item: T) async throws
   }
   
   public final class DatabaseManager: DatabaseManagerProtocol {
       private let modelContainer: ModelContainer
       private let modelContext: ModelContext
       
       public init() throws {
           let schema = Schema([
               // ëª¨ë¸ ìŠ¤í‚¤ë§ˆ ì •ì˜
           ])
           self.modelContainer = try ModelContainer(for: schema)
           self.modelContext = ModelContext(modelContainer)
       }
       
       public func save<T: PersistentModel>(_ item: T) async throws {
           modelContext.insert(item)
           try modelContext.save()
       }
       
       public func fetch<T: PersistentModel>(_ type: T.Type, predicate: Predicate<T>? = nil) async throws -> [T] {
           let descriptor = FetchDescriptor<T>(predicate: predicate)
           return try modelContext.fetch(descriptor)
       }
       
       public func delete<T: PersistentModel>(_ item: T) async throws {
           modelContext.delete(item)
           try modelContext.save()
       }
   }
   ```

#### 5-6ì¼ì°¨: Repository íŒ¨í„´ ì¸í„°í˜ì´ìŠ¤ ìœ ì§€í•˜ë©° êµ¬í˜„ ë¶„ë¦¬
1. **ë°ì´í„° ì•¡ì„¸ìŠ¤ ê³„ì¸µ ì •ì˜**
   ```swift
   // DatabaseModule/Sources/DataSources/LocalDataSource.swift
   import Foundation
   
   public protocol LocalDataSource {
       func save<T: Codable>(_ item: T, forKey key: String) throws
       func retrieve<T: Codable>(_ type: T.Type, forKey key: String) throws -> T?
       func remove(forKey key: String) throws
   }
   
   public final class DefaultLocalDataSource: LocalDataSource {
       private let databaseManager: DatabaseManagerProtocol
       
       public init(databaseManager: DatabaseManagerProtocol) {
           self.databaseManager = databaseManager
       }
       
       // êµ¬í˜„...
   }
   ```

2. **DataModuleì˜ ë¡œì»¬ ì €ì¥ì†Œ ì˜ì¡´ì„± ìˆ˜ì •**
   ```swift
   // DataModule/Sources/Repositories/AccountRepository.swift
   import Foundation
   import DomainModule
   import DatabaseModule
   
   public final class AccountRepositoryImpl: AccountRepository {
       private let remoteDataSource: AccountRemoteDataSource
       private let localDataSource: LocalDataSource // DatabaseModuleì—ì„œ ê°€ì ¸ì˜´
       
       public init(remoteDataSource: AccountRemoteDataSource, localDataSource: LocalDataSource) {
           self.remoteDataSource = remoteDataSource
           self.localDataSource = localDataSource
       }
       
       // êµ¬í˜„...
   }
   ```

3. **DI ì»¨í…Œì´ë„ˆ ì—…ë°ì´íŠ¸**
   ```swift
   // DataModule/Sources/DIContainer/DataDIContainer.swift
   import Foundation
   import NetworkModule
   import DatabaseModule
   
   public final class DataDIContainer {
       private let networkContainer: NetworkDIContainer
       private let databaseManager: DatabaseManagerProtocol
       
       public init(networkContainer: NetworkDIContainer, databaseManager: DatabaseManagerProtocol) {
           self.networkContainer = networkContainer
           self.databaseManager = databaseManager
       }
       
       // ì˜ì¡´ì„± ì œê³µ ë©”ì„œë“œ...
   }
   ```

#### 7ì¼ì°¨: ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë¡œ ê¸°ëŠ¥ ê²€ì¦
1. **ë°ì´í„°ë² ì´ìŠ¤ ëª¨ë“ˆ í…ŒìŠ¤íŠ¸ ì‘ì„±**
   ```swift
   // DatabaseModuleTests/DatabaseManagerTests.swift
   import XCTest
   @testable import DatabaseModule
   
   final class DatabaseManagerTests: XCTestCase {
       var sut: DatabaseManager!
       
       override func setUp() {
           super.setUp()
           // ì¸ë©”ëª¨ë¦¬ ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •
           sut = try! DatabaseManager(inMemory: true)
       }
       
       override func tearDown() {
           sut = nil
           super.tearDown()
       }
       
       func test_SaveAndFetch() async throws {
           // í…ŒìŠ¤íŠ¸ êµ¬í˜„
       }
       
       // ì¶”ê°€ í…ŒìŠ¤íŠ¸...
   }
   ```

2. **ê¸°ì¡´ Repository í…ŒìŠ¤íŠ¸ ìˆ˜ì •**
   - ë°ì´í„°ë² ì´ìŠ¤ ëª¨ë“ˆ ì˜ì¡´ì„± ì¶”ê°€ë¡œ ì¸í•œ í…ŒìŠ¤íŠ¸ ìˆ˜ì •
   - ëª¨ì˜ ê°ì²´ ìƒì„± ë¡œì§ ì—…ë°ì´íŠ¸

3. **í†µí•© í…ŒìŠ¤íŠ¸ ì‹¤í–‰**
   ```bash
   tuist test DatabaseModule
   tuist test DataModule
   ```

### 3-2: NetworkModule ìµœì í™” (1ì£¼)

#### 8-9ì¼ì°¨: ë„¤íŠ¸ì›Œí¬ ê³„ì¸µ ì¶”ìƒí™” ê°œì„ 
1. **NetworkClient ì¸í„°í˜ì´ìŠ¤ ì •ë¦¬**
   ```swift
   // NetworkModule/Sources/Core/NetworkClient.swift
   import Foundation
   
   public protocol NetworkClient {
       func request<T: Decodable>(_ endpoint: Endpoint) async throws -> T
       func upload<T: Decodable>(data: Data, to endpoint: Endpoint) async throws -> T
       func download(from endpoint: Endpoint) async throws -> URL
   }
   
   public final class DefaultNetworkClient: NetworkClient {
       private let session: URLSession
       private let plugins: [NetworkPlugin]
       
       public init(session: URLSession = .shared, plugins: [NetworkPlugin] = []) {
           self.session = session
           self.plugins = plugins
       }
       
       // êµ¬í˜„...
   }
   ```

2. **Endpoint êµ¬ì¡° í‘œì¤€í™”**
   ```swift
   // NetworkModule/Sources/Core/Endpoint.swift
   import Foundation
   
   public struct Endpoint {
       public let baseURL: URL
       public let path: String
       public let method: HTTPMethod
       public let task: HTTPTask
       public let headers: [String: String]?
       
       public init(baseURL: URL, 
                  path: String, 
                  method: HTTPMethod, 
                  task: HTTPTask = .requestPlain, 
                  headers: [String: String]? = nil) {
           self.baseURL = baseURL
           self.path = path
           self.method = method
           self.task = task
           self.headers = headers
       }
       
       public func urlRequest() -> URLRequest {
           // URLRequest ìƒì„± ë¡œì§
       }
   }
   ```

3. **ëª¨ë“ˆ ê³µê°œ API ì •ë¦¬**
   - ë‚´ë¶€ìš©/ê³µê°œìš© íƒ€ì… ë¶„ë¦¬
   - ë„¤íŠ¸ì›Œí¬ ëª¨ë“ˆ ê³µê°œ ì¸í„°í˜ì´ìŠ¤ ìµœì†Œí™”

#### 10-12ì¼ì°¨: ì—ëŸ¬ ì²˜ë¦¬ ë©”ì»¤ë‹ˆì¦˜ í‘œì¤€í™”
1. **ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ì •ì˜ ê°œì„ **
   ```swift
   // NetworkModule/Sources/Errors/NetworkError.swift
   import Foundation
   
   public enum NetworkError: Error {
       case invalidRequest
       case invalidResponse
       case httpError(statusCode: Int, data: Data?)
       case decodingError(Error)
       case connectionError(Error)
       case serverError(message: String)
       case unauthorized
       case unknown
       
       public var isRetryable: Bool {
           switch self {
           case .connectionError, .serverError:
               return true
           case .httpError(let statusCode, _):
               return statusCode >= 500
           default:
               return false
           }
       }
   }
   
   extension NetworkError: LocalizedError {
       public var errorDescription: String? {
           switch self {
           case .invalidRequest:
               return "ìœ íš¨í•˜ì§€ ì•Šì€ ìš”ì²­ì…ë‹ˆë‹¤."
           // ì¶”ê°€ ì¼€ì´ìŠ¤...
           }
       }
   }
   ```

2. **ì—ëŸ¬ ì¸í„°ì…‰í„° êµ¬í˜„**
   ```swift
   // NetworkModule/Sources/Plugins/ErrorInterceptorPlugin.swift
   import Foundation
   
   public final class ErrorInterceptorPlugin: NetworkPlugin {
       public init() {}
       
       public func prepare(_ request: URLRequest) -> URLRequest {
           return request
       }
       
       public func process(_ result: Result<(Data, URLResponse), Error>, for request: URLRequest) -> Result<(Data, URLResponse), Error> {
           switch result {
           case .success(let response):
               let (data, urlResponse) = response
               guard let httpResponse = urlResponse as? HTTPURLResponse else {
                   return .failure(NetworkError.invalidResponse)
               }
               
               switch httpResponse.statusCode {
               case 200...299:
                   return .success(response)
               case 401:
                   return .failure(NetworkError.unauthorized)
               case 400...499:
                   return .failure(NetworkError.httpError(statusCode: httpResponse.statusCode, data: data))
               case 500...599:
                   return .failure(NetworkError.serverError(message: String(data: data, encoding: .utf8) ?? "ì„œë²„ ì˜¤ë¥˜"))
               default:
                   return .failure(NetworkError.unknown)
               }
           case .failure(let error):
               if let urlError = error as? URLError {
                   return .failure(NetworkError.connectionError(urlError))
               }
               return .failure(error)
           }
       }
   }
   ```

3. **ì—ëŸ¬ í•¸ë“¤ë§ ê°€ì´ë“œ ì‘ì„±**
   ```markdown
   # ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ í•¸ë“¤ë§ ê°€ì´ë“œ
   
   ## ê°œìš”
   ì´ ë¬¸ì„œëŠ” ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ë¥¼ íš¨ê³¼ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ëŠ” í‘œì¤€ ë°©ì‹ì„ ì„¤ëª…í•©ë‹ˆë‹¤.
   
   ## ì—ëŸ¬ íƒ€ì…
   - `NetworkError` - ë„¤íŠ¸ì›Œí¬ ê³„ì¸µì˜ ëª¨ë“  ì—ëŸ¬ë¥¼ í‘œí˜„
   - `DomainError` - ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ê´€ì ì—ì„œì˜ ì—ëŸ¬ í‘œí˜„
   
   ## ì—ëŸ¬ ë³€í™˜ ê³¼ì •
   1. ë„¤íŠ¸ì›Œí¬ ìš”ì²­ ì‹¤íŒ¨ â†’ NetworkError ìƒì„±
   2. Repositoryì—ì„œ NetworkError â†’ DomainError ë³€í™˜
   3. UseCaseì—ì„œ ì ì ˆí•œ ì—ëŸ¬ ì²˜ë¦¬ ë° ì „íŒŒ
   4. ViewModelì—ì„œ ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ì—ëŸ¬ ë©”ì‹œì§€ ê²°ì •
   
   ## ì½”ë“œ ì˜ˆì‹œ
   ```swift
   // ì½”ë“œ ì˜ˆì‹œ
   ```
   ```

#### 13-14ì¼ì°¨: í”ŒëŸ¬ê·¸ì¸ ì‹œìŠ¤í…œ ê°•í™”
1. **í”ŒëŸ¬ê·¸ì¸ ì¸í„°í˜ì´ìŠ¤ ê°œì„ **
   ```swift
   // NetworkModule/Sources/Plugins/NetworkPlugin.swift
   import Foundation
   
   public protocol NetworkPlugin {
       func prepare(_ request: URLRequest) -> URLRequest
       func process(_ result: Result<(Data, URLResponse), Error>, for request: URLRequest) -> Result<(Data, URLResponse), Error>
       func willSend(_ request: URLRequest)
       func didReceive(_ result: Result<(Data, URLResponse), Error>, for request: URLRequest)
   }
   
   // ê¸°ë³¸ êµ¬í˜„ìœ¼ë¡œ ì„ íƒì  ì˜¤ë²„ë¼ì´ë“œ ì§€ì›
   public extension NetworkPlugin {
       func willSend(_ request: URLRequest) {}
       func didReceive(_ result: Result<(Data, URLResponse), Error>, for request: URLRequest) {}
   }
   ```

2. **í‘œì¤€ í”ŒëŸ¬ê·¸ì¸ êµ¬í˜„**
   ```swift
   // NetworkModule/Sources/Plugins/LoggingPlugin.swift
   import Foundation
   import OSLog
   
   public final class LoggingPlugin: NetworkPlugin {
       private let logger = Logger(subsystem: "com.tossbankclone", category: "Network")
       
       public init() {}
       
       public func prepare(_ request: URLRequest) -> URLRequest {
           return request
       }
       
       public func willSend(_ request: URLRequest) {
           logger.debug("ğŸš€ REQUEST: \(request.url?.absoluteString ?? "unknown")")
           if let headers = request.allHTTPHeaderFields, !headers.isEmpty {
               logger.debug("ğŸ“‹ HEADERS: \(headers)")
           }
           if let body = request.httpBody, let bodyString = String(data: body, encoding: .utf8) {
               logger.debug("ğŸ“¦ BODY: \(bodyString)")
           }
       }
       
       public func process(_ result: Result<(Data, URLResponse), Error>, for request: URLRequest) -> Result<(Data, URLResponse), Error> {
           return result
       }
       
       public func didReceive(_ result: Result<(Data, URLResponse), Error>, for request: URLRequest) {
           switch result {
           case .success(let response):
               let (data, urlResponse) = response
               if let httpResponse = urlResponse as? HTTPURLResponse {
                   logger.debug("âœ… RESPONSE: \(httpResponse.statusCode) - \(request.url?.absoluteString ?? "unknown")")
               }
               if let responseString = String(data: data, encoding: .utf8) {
                   logger.debug("ğŸ“„ DATA: \(responseString)")
               }
           case .failure(let error):
               logger.error("âŒ ERROR: \(error.localizedDescription) - \(request.url?.absoluteString ?? "unknown")")
           }
       }
   }
   ```

3. **í”ŒëŸ¬ê·¸ì¸ í™œìš© ìµœì í™”**
   ```swift
   // NetworkModule/Sources/DIContainer/NetworkDIContainer.swift
   import Foundation
   
   public final class NetworkDIContainer {
       public func makeNetworkClient() -> NetworkClient {
           let plugins: [NetworkPlugin] = [
               AuthorizationPlugin(tokenProvider: makeTokenProvider()),
               ErrorInterceptorPlugin(),
               LoggingPlugin(),
               NetworkActivityPlugin(),
               // ì¶”ê°€ í”ŒëŸ¬ê·¸ì¸...
           ]
           
           return DefaultNetworkClient(plugins: plugins)
       }
       
       // ì¶”ê°€ ë©”ì„œë“œ...
   }
   ```

### 3-3: DomainModule ë° AuthenticationModule ì •ë¦¬ (1ì£¼)

#### 15-16ì¼ì°¨: ì—”í‹°í‹° ëª¨ë¸ ìµœì í™”
1. **ë„ë©”ì¸ ì—”í‹°í‹° ì¬ì •ì˜**
   ```swift
   // DomainModule/Sources/Entities/Account.swift
   import Foundation
   
   public struct Account: Equatable, Identifiable {
       public let id: String
       public let name: String
       public let type: AccountType
       public let balance: Decimal
       public let currency: Currency
       public let isActive: Bool
       public let createdAt: Date
       
       public init(id: String, name: String, type: AccountType, balance: Decimal, currency: Currency, isActive: Bool, createdAt: Date) {
           self.id = id
           self.name = name
           self.type = type
           self.balance = balance
           self.currency = currency
           self.isActive = isActive
           self.createdAt = createdAt
       }
   }
   
   public enum AccountType: String, Codable, CaseIterable {
       case checking
       case savings
       case investment
       
       public var displayName: String {
           switch self {
           case .checking: return "ì…ì¶œê¸ˆ"
           case .savings: return "ì ê¸ˆ"
           case .investment: return "íˆ¬ì"
           }
       }
   }
   
   public enum Currency: String, Codable {
       case krw = "KRW"
       case usd = "USD"
       case eur = "EUR"
       case jpy = "JPY"
       
       public var symbol: String {
           switch self {
           case .krw: return "â‚©"
           case .usd: return "$"
           case .eur: return "â‚¬"
           case .jpy: return "Â¥"
           }
       }
   }
   ```

2. **ê°’ ê°ì²´(Value Object) ë„ì…**
   ```swift
   // DomainModule/Sources/Entities/Money.swift
   import Foundation
   
   public struct Money: Equatable, Codable {
       public let amount: Decimal
       public let currency: Currency
       
       public init(amount: Decimal, currency: Currency) {
           self.amount = amount
           self.currency = currency
       }
       
       public func formatted() -> String {
           let formatter = NumberFormatter()
           formatter.numberStyle = .currency
           formatter.currencySymbol = currency.symbol
           formatter.minimumFractionDigits = 0
           formatter.maximumFractionDigits = 2
           
           return formatter.string(from: amount as NSDecimalNumber) ?? "\(currency.symbol)\(amount)"
       }
       
       // ëˆ ì—°ì‚° ë©”ì„œë“œ ì¶”ê°€ (ë§ì…ˆ, ëº„ì…ˆ ë“±)
   }
   ```

3. **ë„ë©”ì¸ ì˜¤ë¥˜ ì •ì˜**
   ```swift
   // DomainModule/Sources/Entities/DomainError.swift
   import Foundation
   
   public enum DomainError: Error {
       case invalidInput
       case entityNotFound
       case permissionDenied
       case insufficientFunds
       case serviceUnavailable
       case networkError(message: String)
       case authenticationRequired
       case validationFailed(field: String, message: String)
       case unknown
   }
   
   extension DomainError: LocalizedError {
       public var errorDescription: String? {
           switch self {
           case .invalidInput:
               return "ìœ íš¨í•˜ì§€ ì•Šì€ ì…ë ¥ì…ë‹ˆë‹¤."
           case .entityNotFound:
               return "ìš”ì²­í•œ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
           case .permissionDenied:
               return "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤."
           case .insufficientFunds:
               return "ì”ì•¡ì´ ë¶€ì¡±í•©ë‹ˆë‹¤."
           case .serviceUnavailable:
               return "ì„œë¹„ìŠ¤ë¥¼ ì´ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”."
           case .networkError(let message):
               return "ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: \(message)"
           case .authenticationRequired:
               return "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤."
           case .validationFailed(let field, let message):
               return "\(field): \(message)"
           case .unknown:
               return "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."
           }
       }
   }
   ```

#### 17-18ì¼ì°¨: ìœ ìŠ¤ì¼€ì´ìŠ¤ êµ¬ì¡° ê°œì„ 
1. **ê¸°ë³¸ ìœ ìŠ¤ì¼€ì´ìŠ¤ í”„ë¡œí† ì½œ ì •ì˜**
   ```swift
   // DomainModule/Sources/UseCases/UseCase.swift
   import Foundation
   
   public protocol UseCase {
       associatedtype Input
       associatedtype Output
       
       func execute(input: Input) async throws -> Output
   }
   
   public protocol NoInputUseCase {
       associatedtype Output
       
       func execute() async throws -> Output
   }
   
   public protocol NoOutputUseCase {
       associatedtype Input
       
       func execute(input: Input) async throws
   }
   
   public protocol SimpleUseCase {
       func execute() async throws
   }
   ```

2. **ìœ ìŠ¤ì¼€ì´ìŠ¤ êµ¬í˜„ í‘œì¤€í™”**
   ```swift
   // DomainModule/Sources/UseCases/Account/GetAccountsUseCase.swift
   import Foundation
   
   public final class GetAccountsUseCase: NoInputUseCase {
       public typealias Output = [Account]
       
       private let accountRepository: AccountRepository
       
       public init(accountRepository: AccountRepository) {
           self.accountRepository = accountRepository
       }
       
       public func execute() async throws -> [Account] {
           return try await accountRepository.getAccounts()
       }
   }
   
   // DomainModule/Sources/UseCases/Transfer/TransferMoneyUseCase.swift
   public struct TransferMoneyInput {
       public let sourceAccountId: String
       public let destinationAccountId: String
       public let amount: Money
       public let description: String?
       
       public init(sourceAccountId: String, destinationAccountId: String, amount: Money, description: String? = nil) {
           self.sourceAccountId = sourceAccountId
           self.destinationAccountId = destinationAccountId
           self.amount = amount
           self.description = description
       }
   }
   
   public final class TransferMoneyUseCase: UseCase {
       public typealias Input = TransferMoneyInput
       public typealias Output = TransferResult
       
       private let accountRepository: AccountRepository
       private let transferRepository: TransferRepository
       
       public init(accountRepository: AccountRepository, transferRepository: TransferRepository) {
           self.accountRepository = accountRepository
           self.transferRepository = transferRepository
       }
       
       public func execute(input: TransferMoneyInput) async throws -> TransferResult {
           // êµ¬í˜„...
       }
   }
   ```

3. **DIContainer ì—…ë°ì´íŠ¸**
   ```swift
   // DomainModule/Sources/DIContainer/DomainDIContainer.swift
   import Foundation
   
   public final class DomainDIContainer {
       private let repositories: RepositoryProvider
       
       public init(repositories: RepositoryProvider) {
           self.repositories = repositories
       }
       
       // ê³„ì¢Œ ê´€ë ¨ ìœ ìŠ¤ì¼€ì´ìŠ¤
       public func makeGetAccountsUseCase() -> GetAccountsUseCase {
           return GetAccountsUseCase(accountRepository: repositories.makeAccountRepository())
       }
       
       public func makeGetAccountDetailUseCase() -> GetAccountDetailUseCase {
           return GetAccountDetailUseCase(accountRepository: repositories.makeAccountRepository())
       }
       
       // ì´ì²´ ê´€ë ¨ ìœ ìŠ¤ì¼€ì´ìŠ¤
       public func makeTransferMoneyUseCase() -> TransferMoneyUseCase {
           return TransferMoneyUseCase(
               accountRepository: repositories.makeAccountRepository(),
               transferRepository: repositories.makeTransferRepository()
           )
       }
       
       // ì¶”ê°€ ìœ ìŠ¤ì¼€ì´ìŠ¤ íŒ©í† ë¦¬ ë©”ì„œë“œ...
   }
   ```

#### 19-21ì¼ì°¨: ì¸ì¦ ê´€ë ¨ ì±…ì„ ëª…í™•í™”
1. **AuthenticationModule ì¸í„°í˜ì´ìŠ¤ ê°œì„ **
   ```swift
   // AuthenticationModule/Sources/Manager/AuthManager.swift
   import Foundation
   
   public protocol AuthManagerProtocol {
       var isAuthenticated: Bool { get }
       var currentUser: User? { get }
       
       func signIn(username: String, password: String) async throws -> User
       func signOut() async throws
       func refreshToken() async throws -> String
       func getAccessToken() async throws -> String
   }
   
   public final class AuthManager: AuthManagerProtocol {
       private let authRepository: AuthRepository
       private let tokenStorage: TokenStorage
       private let userSession: UserSession
       
       public init(authRepository: AuthRepository, tokenStorage: TokenStorage, userSession: UserSession) {
           self.authRepository = authRepository
           self.tokenStorage = tokenStorage
           self.userSession = userSession
       }
       
       public var isAuthenticated: Bool {
           return userSession.currentUser != nil && tokenStorage.hasValidToken
       }
       
       public var currentUser: User? {
           return userSession.currentUser
       }
       
       public func signIn(username: String, password: String) async throws -> User {
           let authResponse = try await authRepository.signIn(username: username, password: password)
           
           try tokenStorage.saveTokens(access: authResponse.accessToken, refresh: authResponse.refreshToken)
           let user = authResponse.user
           userSession.setCurrentUser(user)
           
           return user
       }
       
       public func signOut() async throws {
           try tokenStorage.clearTokens()
           userSession.clearCurrentUser()
           try? await authRepository.signOut()
       }
       
       public func refreshToken() async throws -> String {
           guard let refreshToken = tokenStorage.refreshToken else {
               throw AuthError.noRefreshToken
           }
           
           let tokens = try await authRepository.refreshToken(refreshToken: refreshToken)
           try tokenStorage.saveTokens(access: tokens.accessToken, refresh: tokens.refreshToken)
           
           return tokens.accessToken
       }
       
       public func getAccessToken() async throws -> String {
           if let token = tokenStorage.accessToken, !tokenStorage.isAccessTokenExpired {
               return token
           }
           
           return try await refreshToken()
       }
   }
   ```

2. **í† í° ê´€ë¦¬ ìµœì í™”**
   ```swift
   // AuthenticationModule/Sources/Manager/TokenStorage.swift
   import Foundation
   import KeychainAccess
   
   public protocol TokenStorage {
       var accessToken: String? { get }
       var refreshToken: String? { get }
       var hasValidToken: Bool { get }
       var isAccessTokenExpired: Bool { get }
       
       func saveTokens(access: String, refresh: String) throws
       func clearTokens() throws
   }
   
   public final class KeychainTokenStorage: TokenStorage {
       private let keychain: Keychain
       private let accessTokenKey = "access_token"
       private let refreshTokenKey = "refresh_token"
       private let accessTokenExpiryKey = "access_token_expiry"
       
       public init() {
           self.keychain = Keychain(service: "com.tossbankclone.auth")
       }
       
       public var accessToken: String? {
           try? keychain.get(accessTokenKey)
       }
       
       public var refreshToken: String? {
           try? keychain.get(refreshTokenKey)
       }
       
       public var hasValidToken: Bool {
           return accessToken != nil && refreshToken != nil
       }
       
       public var isAccessTokenExpired: Bool {
           guard let expiryString = try? keychain.get(accessTokenExpiryKey),
                 let expiry = Double(expiryString) else {
               return true
           }
           
           return Date().timeIntervalSince1970 > expiry
       }
       
       public func saveTokens(access: String, refresh: String) throws {
           // ì•¡ì„¸ìŠ¤ í† í° ë§Œë£Œ ì‹œê°„ ê³„ì‚° (í˜„ì¬ ì‹œê°„ + 1ì‹œê°„)
           let expiry = Date().timeIntervalSince1970 + 3600
           
           try keychain
               .set(access, key: accessTokenKey)
               .set(refresh, key: refreshTokenKey)
               .set(String(expiry), key: accessTokenExpiryKey)
       }
       
       public func clearTokens() throws {
           try keychain
               .remove(accessTokenKey)
               .remove(refreshTokenKey)
               .remove(accessTokenExpiryKey)
       }
   }
   ```

3. **ì¸ì¦ ì²˜ë¦¬ íë¦„ ë¬¸ì„œí™”**
   ```markdown
   # ì¸ì¦ íë¦„ ê°€ì´ë“œ
   
   ## ê°œìš”
   ì´ ë¬¸ì„œëŠ” ì•±ì˜ ì¸ì¦ ì²˜ë¦¬ íë¦„ì„ ì„¤ëª…í•©ë‹ˆë‹¤.
   
   ## ì¸ì¦ ìƒíƒœ ê´€ë¦¬
   - `AuthManager`ëŠ” ì‚¬ìš©ìì˜ ì¸ì¦ ìƒíƒœë¥¼ ì¤‘ì•™ì—ì„œ ê´€ë¦¬í•©ë‹ˆë‹¤.
   - `TokenStorage`ëŠ” ì¸ì¦ í† í°ì„ ì•ˆì „í•˜ê²Œ ì €ì¥í•˜ê³  ê´€ë¦¬í•©ë‹ˆë‹¤.
   - `UserSession`ì€ í˜„ì¬ ë¡œê·¸ì¸í•œ ì‚¬ìš©ì ì •ë³´ë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤.
   
   ## ì¸ì¦ íë¦„
   1. ë¡œê·¸ì¸: ì‚¬ìš©ì ì¸ì¦ ì •ë³´ë¡œ API í˜¸ì¶œ â†’ í† í° ë°œê¸‰ â†’ í† í° ì €ì¥ â†’ ì‚¬ìš©ì ì„¸ì…˜ ìƒì„±
   2. API ìš”ì²­: ì•¡ì„¸ìŠ¤ í† í° í™•ì¸ â†’ ë§Œë£Œ ì‹œ ê°±ì‹  â†’ ìš”ì²­ì— í† í° ì²¨ë¶€
   3. ë¡œê·¸ì•„ì›ƒ: í† í° ì‚­ì œ â†’ ì‚¬ìš©ì ì„¸ì…˜ ì œê±° â†’ ì„œë²„ì— ë¡œê·¸ì•„ì›ƒ ì•Œë¦¼
   
   ## í† í° ê°±ì‹  ì „ëµ
   - ì•¡ì„¸ìŠ¤ í† í° ë§Œë£Œ ì‹œ ìë™ìœ¼ë¡œ ë¦¬í”„ë ˆì‹œ í† í°ì„ ì‚¬ìš©í•˜ì—¬ ê°±ì‹ 
   - ë¦¬í”„ë ˆì‹œ í† í°ë„ ë§Œë£Œëœ ê²½ìš° ì‚¬ìš©ìì—ê²Œ ì¬ë¡œê·¸ì¸ ìš”ì²­
   
   ## ì˜¤ë¥˜ ì²˜ë¦¬
   - ì¸ì¦ ì˜¤ë¥˜ ë°œìƒ ì‹œ ì ì ˆí•œ ì‚¬ìš©ì í”¼ë“œë°± ì œê³µ
   - 401 ì—ëŸ¬ ë°œìƒ ì‹œ í† í° ê°±ì‹  ì‹œë„ í›„ ì¬ì‹œë„
   ```

## 3ë‹¨ê³„ ì‚°ì¶œë¬¼ ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] Database ëª¨ë“ˆ ìƒì„± ë° ì½”ë“œ ì´ì „ ì™„ë£Œ
- [ ] Repository íŒ¨í„´ ì¸í„°í˜ì´ìŠ¤ ìœ ì§€í•˜ë©° êµ¬í˜„ ë¶„ë¦¬ ì™„ë£Œ
- [ ] DataModuleê³¼ DatabaseModule ê°„ ì˜ì¡´ì„± ì„¤ì • ì™„ë£Œ
- [ ] NetworkModule ì¶”ìƒí™” ê³„ì¸µ ê°œì„  ì™„ë£Œ
- [ ] ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ ì²˜ë¦¬ ë©”ì»¤ë‹ˆì¦˜ í‘œì¤€í™” ì™„ë£Œ
- [ ] í”ŒëŸ¬ê·¸ì¸ ì‹œìŠ¤í…œ ê°•í™” ì™„ë£Œ
- [ ] DomainModule ì—”í‹°í‹° ë° ìœ ìŠ¤ì¼€ì´ìŠ¤ ìµœì í™” ì™„ë£Œ
- [ ] AuthenticationModule ì¸í„°í˜ì´ìŠ¤ ë° ì±…ì„ ëª…í™•í™” ì™„ë£Œ
- [ ] ëª¨ë“  ë³€ê²½ì‚¬í•­ì— ëŒ€í•œ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„± ì™„ë£Œ
- [ ] 3ë‹¨ê³„ ì™„ë£Œ ë³´ê³ ì„œ ë° 4ë‹¨ê³„ ì„¸ë¶€ ê³„íš

ì´ 3ë‹¨ê³„ ì‹¤í–‰ ê³„íšì„ í†µí•´ ì½”ì–´ ëª¨ë“ˆì˜ êµ¬ì¡°ë¥¼ ê°œì„ í•˜ê³ , ì•„í‚¤í…ì²˜ ë¬¸ì„œì— ì œì‹œëœ ì´ìƒì ì¸ êµ¬ì¡°ì— ê°€ê¹ê²Œ ë°œì „ì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
