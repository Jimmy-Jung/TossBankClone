
# 토스뱅크 클론 프로젝트 리팩터링 5단계 실행 계획

## 5단계: 의존성 최적화 및 통합 테스트 (2주)

### 5-1: 모듈 간 의존성 최적화 (1주)

#### 1-2일차: 상위 모듈이 하위 모듈에만 의존하도록 조정
1. **의존성 방향 분석**
   ```bash
   # 현재 의존성 방향 분석
   find App/Modules -name "Project.swift" -exec grep -l "dependencies" {} \; | xargs grep -A20 "dependencies"
   ```

2. **의존성 방향 표준화**
   ```swift
   // 올바른 의존성 방향 예시 (Features → Core/Platform)
   // App/Modules/Features/Account/Project.swift
   
   let dependencies: [TargetDependency] = [
       .project(target: "DomainModule", path: "../../../DomainModule"),
       .project(target: "SharedModule", path: "../../../SharedModule"),
       .project(target: "DesignSystem", path: "../../../DesignSystem"),
       // 잘못된 예: .project(target: "AuthModule", path: "../../Auth") - 기능 모듈끼리 직접 의존
   ]
   ```

3. **모듈 경계 정의 문서 작성**
   ```markdown
   # 모듈 의존성 가이드라인
   
   ## 모듈 계층
   1. **앱 모듈**: 최상위 계층, 모든 모듈에 의존 가능
   2. **기능 모듈**: 코어 모듈과 플랫폼 모듈에만 의존 가능
   3. **코어 모듈**: 다른 코어 모듈과 플랫폼 모듈에만 의존 가능
   4. **플랫폼 모듈**: 외부 종속성에만 의존 가능
   
   ## 의존성 규칙
   - 상위 모듈은 하위 모듈에 의존할 수 있다
   - 동일 계층 내 의존성은 가능한 최소화한다
   - 하위 모듈이 상위 모듈에 의존하는 것은 금지된다
   - 코어 모듈 간 의존성 순서: Domain → Data → Network/Database
   
   ## 의존성 역전 원칙 적용
   [예시 포함]
   ```

#### 3-4일차: 순환 의존성 제거
1. **의존성 그래프 분석**
   ```bash
   # Tuist의 의존성 그래프 생성
   tuist graph
   # 그래프에서 순환 의존성 확인
   ```

2. **순환 의존성 제거 전략 구현**
   ```swift
   // 순환 의존성 예시: A → B → C → A
   
   // 1. 인터페이스 추출 방식으로 해결
   // A가 C에 의존하는 대신 인터페이스를 통해 의존하게 변경
   
   // DomainModule/Sources/Protocols/MessageServiceProtocol.swift
   public protocol MessageServiceProtocol {
       func sendMessage(_ message: String, to recipient: String) async throws
   }
   
   // NetworkModule에서 MessageServiceProtocol 구현체 제공
   // NetworkModule/Sources/Services/MessageService.swift
   public final class MessageService: MessageServiceProtocol {
       public func sendMessage(_ message: String, to recipient: String) async throws {
           // 구현...
       }
   }
   
   // 2. 중간 모듈 도입 방식으로 해결
   // A와 C 사이의 공통 인터페이스를 새 모듈로 분리
   ```

3. **의존성 방향 정리**
   ```swift
   // Project.swift 수정
   // 잘못된 의존성 방향 수정
   
   // 기존: 
   let dependencies: [TargetDependency] = [
       .project(target: "LowerModule", path: "../LowerModule"),
       .project(target: "SameLayerModule", path: "../SameLayerModule"), // 필요한 경우만 유지
       .project(target: "HigherModule", path: "../HigherModule"), // 제거해야 함
   ]
   
   // 수정:
   let dependencies: [TargetDependency] = [
       .project(target: "LowerModule", path: "../LowerModule"),
       .project(target: "SameLayerModule", path: "../SameLayerModule"), // 필요한 경우만 유지
   ]
   ```

#### 5-7일차: 인터페이스 추상화 개선
1. **코어 모듈 인터페이스 표준화**
   ```swift
   // DomainModule/Sources/Repositories/RepositoryProtocols.swift
   import Foundation
   
   public protocol Repository {
       associatedtype Entity
       associatedtype Identifier
       
       func getAll() async throws -> [Entity]
       func getById(_ id: Identifier) async throws -> Entity
       func create(_ entity: Entity) async throws -> Entity
       func update(_ entity: Entity) async throws -> Entity
       func delete(_ id: Identifier) async throws
   }
   
   // 구체적인 저장소 인터페이스
   public protocol AccountRepository: Repository where Entity == Account, Identifier == String {
       func getAccountsForUser(userId: String) async throws -> [Account]
       func getTransactions(accountId: String, limit: Int?, offset: Int?) async throws -> [Transaction]
   }
   ```

2. **의존성 주입 시스템 개선**
   ```swift
   // SharedModule/Sources/DIContainer/DIContainer.swift
   
   public protocol DIContainer: AnyObject {
       func resolve<T>(_ type: T.Type) -> T
       func register<T>(type: T.Type, factory: @escaping () -> T)
       func register<T, Impl>(type: T.Type, implementation: Impl.Type) where Impl: T
   }
   
   public final class DefaultDIContainer: DIContainer {
       private var factories: [String: () -> Any] = [:]
       
       public init() {}
       
       public func resolve<T>(_ type: T.Type) -> T {
           let key = String(describing: type)
           guard let factory = factories[key] else {
               fatalError("No factory registered for type \(key)")
           }
           
           guard let instance = factory() as? T else {
               fatalError("Factory for \(key) returned incorrect type")
           }
           
           return instance
       }
       
       public func register<T>(type: T.Type, factory: @escaping () -> T) {
           let key = String(describing: type)
           factories[key] = factory
       }
       
       public func register<T, Impl>(type: T.Type, implementation: Impl.Type) where Impl: T {
           register(type: type) { Impl.init() as! T }
       }
   }
   ```

3. **이벤트 기반 통신 시스템 구현**
   ```swift
   // SharedModule/Sources/Notification/EventBus.swift
   import Foundation
   import Combine
   
   public final class EventBus {
       public static let shared = EventBus()
       
       private var subjects: [String: PassthroughSubject<Any, Never>] = [:]
       private var cancellables = Set<AnyCancellable>()
       
       private init() {}
       
       public func publish<T>(_ event: T, as eventType: String? = nil) {
           let eventName = eventType ?? String(describing: type(of: T.self))
           if subjects[eventName] == nil {
               subjects[eventName] = PassthroughSubject<Any, Never>()
           }
           subjects[eventName]?.send(event)
       }
       
       public func subscribe<T>(_ eventType: String? = nil, handler: @escaping (T) -> Void) -> AnyCancellable {
           let eventName = eventType ?? String(describing: type(of: T.self))
           if subjects[eventName] == nil {
               subjects[eventName] = PassthroughSubject<Any, Never>()
           }
           
           return subjects[eventName]?
               .compactMap { $0 as? T }
               .sink(receiveValue: handler) ?? AnyCancellable {}
       }
   }
   ```

### 5-2: 통합 테스트 강화 (1주)

#### 8-10일차: 모듈 간 연동 테스트 작성
1. **테스트 계획 수립**
   ```markdown
   # 통합 테스트 계획
   
   ## 테스트 대상 모듈 페어
   1. DomainModule + DataModule
   2. DataModule + NetworkModule
   3. DataModule + DatabaseModule
   4. Feature 모듈 + 코어 모듈
   
   ## 테스트 범위
   - 경계 간 데이터 변환 정확성
   - 비동기 작업 흐름 검증
   - 오류 전파 및 처리
   - 의존성 주입 동작 검증
   ```

2. **통합 테스트 프레임워크 설정**
   ```swift
   // App/Tests/IntegrationTests/IntegrationTestCase.swift
   import XCTest
   import DomainModule
   import DataModule
   import NetworkModule
   import DatabaseModule
   import TestingModule
   
   class IntegrationTestCase: XCTestCase {
       var mockNetworkClient: MockNetworkClient!
       var mockDatabaseManager: MockDatabaseManager!
       var testDataFactory: TestDataFactory!
       
       override func setUp() {
           super.setUp()
           mockNetworkClient = MockNetworkClient()
           mockDatabaseManager = MockDatabaseManager()
           testDataFactory = TestDataFactory()
       }
       
       override func tearDown() {
           mockNetworkClient = nil
           mockDatabaseManager = nil
           testDataFactory = nil
           super.tearDown()
       }
   }
   ```

3. **모듈 간 연동 테스트 구현**
   ```swift
   // App/Tests/IntegrationTests/DataNetworkIntegrationTests.swift
   import XCTest
   import DomainModule
   import DataModule
   import NetworkModule
   
   final class DataNetworkIntegrationTests: IntegrationTestCase {
       var accountRepository: AccountRepositoryImpl!
       var networkAPIClient: NetworkAPIClient!
       
       override func setUp() {
           super.setUp()
           networkAPIClient = NetworkAPIClient(networkClient: mockNetworkClient)
           accountRepository = AccountRepositoryImpl(
               remoteDataSource: AccountRemoteDataSource(apiClient: networkAPIClient),
               localDataSource: nil // 네트워크 테스트에 집중
           )
       }
       
       func testGetAccountsFlow() async throws {
           // 준비
           let mockAccounts = testDataFactory.createTestAccounts(count: 3)
           let mockResponse = MockNetworkResponse.success(with: mockAccounts.map { AccountDTO(from: $0) })
           
           mockNetworkClient.register(
               endpoint: AccountEndpoint.getAccounts,
               response: mockResponse
           )
           
           // 실행
           let accounts = try await accountRepository.getAccounts()
           
           // 검증
           XCTAssertEqual(accounts.count, 3)
           XCTAssertEqual(accounts[0].id, mockAccounts[0].id)
           XCTAssertEqual(accounts[1].name, mockAccounts[1].name)
           XCTAssertEqual(accounts[2].balance, mockAccounts[2].balance)
           XCTAssertEqual(mockNetworkClient.requestLog.count, 1)
       }
       
       func testAccountErrorPropagation() async {
           // 준비
           let networkError = NetworkError.httpError(statusCode: 401, data: nil)
           let mockResponse = MockNetworkResponse.failure(error: networkError)
           
           mockNetworkClient.register(
               endpoint: AccountEndpoint.getAccounts,
               response: mockResponse
           )
           
           // 실행 및 검증
           do {
               _ = try await accountRepository.getAccounts()
               XCTFail("Expected error but got success")
           } catch {
               if let domainError = error as? DomainError {
                   XCTAssertEqual(domainError, .authenticationRequired)
               } else {
                   XCTFail("Expected DomainError but got \(error)")
               }
           }
       }
   }
   ```

#### 11-13일차: 엔드 투 엔드 테스트 시나리오 개발
1. **테스트 시나리오 정의**
   ```markdown
   # 엔드 투 엔드 테스트 시나리오
   
   ## 시나리오 1: 로그인 및 계좌 조회
   1. 앱 시작
   2. 로그인 화면 표시 확인
   3. 로그인 정보 입력 및 제출
   4. 메인 화면 전환 확인
   5. 계좌 목록 화면 이동
   6. 계좌 데이터 표시 확인
   7. 계좌 선택 및 상세 화면 이동
   8. 계좌 상세 데이터 및 거래내역 표시 확인
   
   ## 시나리오 2: 송금 프로세스
   1. 앱 시작 및 로그인
   2. 송금 화면 이동
   3. 출금 계좌 선택
   4. 송금 정보 입력
   5. 송금 확인 화면 검증
   6. 송금 실행 및 결과 확인
   7. 계좌 잔액 변경 확인
   ```

2. **E2E 테스트 구현**
   ```swift
   // App/Tests/UITests/EndToEndTests.swift
   import XCTest
   import TestingModule
   
   final class EndToEndTests: XCTestCase {
       var app: XCUIApplication!
       var routing: UITestRouting!
       
       override func setUp() {
           super.setUp()
           app = XCUIApplication()
           routing = UITestRouting(app: app)
           continueAfterFailure = false
       }
       
       func testLoginAndAccountViewing() {
           // 준비 - 테스트 데이터 설정
           app.launchArguments = ["--UITesting", "--use-mock-data", "--scenario", "multipleAccounts"]
           app.launch()
           
           // 1. 로그인
           XCTAssertTrue(routing.login(username: "test@example.com", password: "password123"))
           
           // 2. 계좌 목록 화면 이동
           XCTAssertTrue(routing.goToAccountList())
           XCTAssertTrue(app.cells["accountCell_0"].waitForExistence(timeout: 2))
           XCTAssertTrue(app.cells["accountCell_1"].waitForExistence(timeout: 2))
           XCTAssertTrue(app.cells["accountCell_2"].waitForExistence(timeout: 2))
           
           // 3. 계좌 상세 화면 이동
           XCTAssertTrue(routing.goToAccountDetail(at: 0))
           XCTAssertTrue(app.staticTexts["accountDetailBalance"].waitForExistence(timeout: 2))
           
           // 스크린샷 저장
           let screenshot = app.screenshot()
           let attachment = XCTAttachment(screenshot: screenshot)
           attachment.lifetime = .keepAlways
           add(attachment)
       }
       
       func testTransferProcess() {
           // 준비 - 테스트 데이터 설정
           app.launchArguments = ["--UITesting", "--use-mock-data", "--scenario", "multipleAccounts"]
           app.launch()
           
           // 1. 로그인
           XCTAssertTrue(routing.login(username: "test@example.com", password: "password123"))
           
           // 2. 송금 화면 이동
           XCTAssertTrue(routing.goToTransfer())
           
           // 3. 송금 정보 입력
           let accountSelector = app.buttons["selectAccountButton"]
           XCTAssertTrue(accountSelector.waitForExistence(timeout: 2))
           accountSelector.tap()
           
           let firstAccount = app.cells["accountCell_0"]
           XCTAssertTrue(firstAccount.waitForExistence(timeout: 2))
           firstAccount.tap()
           
           let amountField = app.textFields["transferAmountField"]
           XCTAssertTrue(amountField.waitForExistence(timeout: 2))
           amountField.tap()
           amountField.typeText("10000")
           
           let recipientField = app.textFields["recipientField"]
           XCTAssertTrue(recipientField.waitForExistence(timeout: 2))
           recipientField.tap()
           recipientField.typeText("테스트 수신자")
           
           // 4. 송금 진행
           let nextButton = app.buttons["nextButton"]
           XCTAssertTrue(nextButton.waitForExistence(timeout: 2))
           nextButton.tap()
           
           // 5. 송금 확인
           let confirmButton = app.buttons["confirmTransferButton"]
           XCTAssertTrue(confirmButton.waitForExistence(timeout: 2))
           confirmButton.tap()
           
           // 6. 결과 확인
           XCTAssertTrue(app.staticTexts["transferSuccessMessage"].waitForExistence(timeout: 5))
           
           // 7. 잔액 변경 확인
           XCTAssertTrue(routing.goToAccountList())
           XCTAssertTrue(app.cells["accountCell_0"].waitForExistence(timeout: 2))
           // 잔액 텍스트 확인 로직...
       }
   }
   ```

#### 14일차: 회귀 테스트 자동화
1. **CI 파이프라인에 통합 테스트 추가**
   ```yaml
   # .github/workflows/integration-tests.yml
   name: Integration Tests
   
   on:
     push:
       branches: [ main, develop ]
     pull_request:
       branches: [ main, develop ]
   
   jobs:
     integration-tests:
       runs-on: macos-latest
       steps:
       - uses: actions/checkout@v3
       - name: Set up Ruby
         uses: ruby/setup-ruby@v1
       - name: Install dependencies
         run: |
           gem install xcpretty
           brew install tuist
       - name: Run integration tests
         run: |
           tuist generate
           xcodebuild test -workspace TossBankClone.xcworkspace -scheme IntegrationTests -destination 'platform=iOS Simulator,name=iPhone 14'
   ```

2. **테스트 보고서 생성**
   ```bash
   # 테스트 보고서 생성 스크립트
   
   # 테스트 실행
   xcodebuild test -workspace TossBankClone.xcworkspace -scheme IntegrationTests -destination 'platform=iOS Simulator,name=iPhone 14' | xcpretty --report junit --output test-reports/integration-tests.xml
   
   # 테스트 커버리지 보고서 생성
   xcrun llvm-cov report -instr-profile=build/coverage.profdata build/Products/Debug-iphonesimulator/TossBankClone.app/TossBankClone > coverage-reports/coverage.txt
   ```

3. **테스트 모니터링 대시보드 설정**
   ```swift
   // TestingSupportApp/TestDashboard.swift
   import SwiftUI
   
   struct TestDashboard: View {
       @State private var testResults: [TestResult] = []
       @State private var isLoading = false
       
       var body: some View {
           NavigationView {
               List {
                   Section("테스트 결과") {
                       ForEach(testResults) { result in
                           TestResultRow(result: result)
                       }
                   }
               }
               .navigationTitle("테스트 대시보드")
               .toolbar {
                   ToolbarItem(placement: .primaryAction) {
                       Button("새로고침") {
                           loadTestResults()
                       }
                   }
               }
               .onAppear {
                   loadTestResults()
               }
           }
       }
       
       private func loadTestResults() {
           // 테스트 결과 로드 로직...
       }
   }
   
   struct TestResult: Identifiable {
       let id = UUID()
       let name: String
       let status: TestStatus
       let duration: TimeInterval
       let message: String?
   }
   
   enum TestStatus: String {
       case success
       case failure
       case skipped
   }
   ```

## 5단계 산출물 체크리스트

- [ ] 모듈 간 의존성 방향 표준화 완료
- [ ] 순환 의존성 제거 완료
- [ ] 인터페이스 추상화 개선 완료
- [ ] 모듈 간 의존성 가이드라인 문서 작성 완료
- [ ] 모듈 간 연동 테스트 작성 완료
- [ ] 엔드 투 엔드 테스트 시나리오 개발 완료
- [ ] 회귀 테스트 자동화 완료
- [ ] 5단계 완료 보고서 및 6단계 세부 계획

이 5단계 실행 계획을 통해 모듈 간 의존성 관계를 정리하고 통합 테스트를 강화하여 리팩터링 과정에서 발생할 수 있는 회귀 문제를 최소화할 수 있습니다. 또한 새로운 기능 개발 시 참고할 수 있는 의존성 가이드라인과 테스트 인프라를 구축함으로써 지속적인 코드 품질 향상에 기여할 것입니다.
