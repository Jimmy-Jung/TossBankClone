
# 토스뱅크 클론 프로젝트 리팩터링 4단계 실행 계획

## 4단계: 플랫폼 모듈 구축 (3주)

### 4-1: Utils 모듈 생성 (1주)

#### 1-2일차: 유틸리티 기능 식별 및 수집
1. **현재 코드베이스 분석**
   ```bash
   # 유틸리티성 코드 탐색
   find App/Modules -type f -name "*Util*.swift" -o -name "*Extension*.swift" -o -name "*Helper*.swift"
   ```

2. **공통 유틸리티 기능 선별**
   - 날짜/시간 처리 유틸리티
   - 문자열 처리 유틸리티
   - 숫자/금액 포맷팅 유틸리티
   - 암호화/복호화 유틸리티
   - 이미지 처리 유틸리티

3. **모듈 구조 설계**
   ```
   Utils/
     ├── Sources/
     │   ├── Date/
     │   ├── String/
     │   ├── Number/
     │   ├── Security/
     │   ├── Image/
     │   ├── Extensions/
     │   └── Helpers/
     ├── Tests/
     └── Resources/
   ```

#### 3-4일차: 공통 확장 기능 통합
1. **기본 타입 확장 구현**
   ```swift
   // UtilsModule/Sources/Extensions/String+Extensions.swift
   import Foundation
   
   public extension String {
       func masked(start: Int, end: Int, mask: Character = "*") -> String {
           guard start < end, start >= 0, end < self.count else { return self }
           
           var result = self
           let startIndex = self.index(self.startIndex, offsetBy: start)
           let endIndex = self.index(self.startIndex, offsetBy: end)
           let range = startIndex..<endIndex
           
           let maskString = String(repeating: mask, count: end - start)
           result.replaceSubrange(range, with: maskString)
           
           return result
       }
       
       func isValidEmail() -> Bool {
           let emailRegex = #"^[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$"#
           return NSPredicate(format: "SELF MATCHES %@", emailRegex).evaluate(with: self)
       }
       
       func trimmed() -> String {
           return self.trimmingCharacters(in: .whitespacesAndNewlines)
       }
       
       // 추가 유틸리티 메서드...
   }
   
   // UtilsModule/Sources/Extensions/Date+Extensions.swift
   import Foundation
   
   public extension Date {
       func formattedString(style: DateFormattingStyle) -> String {
           let formatter = DateFormatter()
           
           switch style {
           case .short:
               formatter.dateStyle = .short
               formatter.timeStyle = .none
           case .medium:
               formatter.dateStyle = .medium
               formatter.timeStyle = .none
           case .long:
               formatter.dateStyle = .long
               formatter.timeStyle = .none
           case .withTime:
               formatter.dateStyle = .medium
               formatter.timeStyle = .short
           case .relative:
               return relativeTimeString()
           case .custom(let format):
               formatter.dateFormat = format
           }
           
           formatter.locale = Locale.current
           return formatter.string(from: self)
       }
       
       private func relativeTimeString() -> String {
           // 상대적 시간 표시 구현...
           return ""
       }
   }
   
   public enum DateFormattingStyle {
       case short
       case medium
       case long
       case withTime
       case relative
       case custom(format: String)
   }
   ```

2. **UIKit/SwiftUI 확장 구현**
   ```swift
   // UtilsModule/Sources/Extensions/UIView+Extensions.swift
   import UIKit
   
   public extension UIView {
       func addCornerRadius(_ radius: CGFloat = 8) {
           layer.cornerRadius = radius
           layer.masksToBounds = true
       }
       
       func addBorder(width: CGFloat = 1, color: UIColor = .lightGray) {
           layer.borderWidth = width
           layer.borderColor = color.cgColor
       }
       
       func addShadow(
           color: UIColor = .black,
           opacity: Float = 0.1,
           offset: CGSize = CGSize(width: 0, height: 2),
           radius: CGFloat = 4
       ) {
           layer.shadowColor = color.cgColor
           layer.shadowOpacity = opacity
           layer.shadowOffset = offset
           layer.shadowRadius = radius
           layer.masksToBounds = false
       }
       
       // 추가 메서드...
   }
   
   // UtilsModule/Sources/Extensions/View+Extensions.swift
   import SwiftUI
   
   public extension View {
       func roundedBorder(_ color: Color = .gray, radius: CGFloat = 8, lineWidth: CGFloat = 1) -> some View {
           self.overlay(
               RoundedRectangle(cornerRadius: radius)
                   .stroke(color, lineWidth: lineWidth)
           )
       }
       
       func cardStyle(backgroundColor: Color = .white) -> some View {
           self
               .padding()
               .background(backgroundColor)
               .cornerRadius(12)
               .shadow(color: .black.opacity(0.1), radius: 4, x: 0, y: 2)
       }
       
       // 추가 메서드...
   }
   ```

3. **Collection 확장 구현**
   ```swift
   // UtilsModule/Sources/Extensions/Collection+Extensions.swift
   import Foundation
   
   public extension Collection {
       /// 안전한 인덱스 접근 - 범위를 벗어난 경우 nil 반환
       subscript(safe index: Index) -> Element? {
           return indices.contains(index) ? self[index] : nil
       }
   }
   
   public extension Array {
       func chunked(into size: Int) -> [[Element]] {
           return stride(from: 0, to: count, by: size).map {
               Array(self[$0..<Swift.min($0 + size, count)])
           }
       }
       
       mutating func moveElement(from oldIndex: Index, to newIndex: Index) {
           guard oldIndex != newIndex else { return }
           guard indices.contains(oldIndex) && indices.contains(newIndex) else { return }
           
           let element = self.remove(at: oldIndex)
           self.insert(element, at: newIndex)
       }
   }
   ```

#### 5-7일차: 표준 유틸리티 라이브러리 구성
1. **유틸리티 클래스 구현**
   ```swift
   // UtilsModule/Sources/Number/CurrencyFormatter.swift
   import Foundation
   
   public final class CurrencyFormatter {
       private let formatter: NumberFormatter
       
       public init(currencyCode: String = "KRW", showSymbol: Bool = true) {
           formatter = NumberFormatter()
           formatter.numberStyle = .currency
           formatter.currencyCode = currencyCode
           formatter.locale = Locale.current
           
           if !showSymbol {
               formatter.currencySymbol = ""
           }
           
           formatter.minimumFractionDigits = 0
           formatter.maximumFractionDigits = 2
       }
       
       public func string(from value: Decimal) -> String {
           return formatter.string(from: value as NSDecimalNumber) ?? "0"
       }
       
       public func string(from value: Double) -> String {
           return formatter.string(from: NSNumber(value: value)) ?? "0"
       }
       
       public func value(from string: String) -> Decimal? {
           guard let number = formatter.number(from: string) else { return nil }
           return number.decimalValue
       }
   }
   
   // UtilsModule/Sources/Security/Encryption.swift
   import Foundation
   import CryptoKit
   
   public enum EncryptionError: Error {
       case encryptionFailed
       case decryptionFailed
       case invalidKey
   }
   
   public final class EncryptionService {
       // AES 암호화/복호화 구현
       public static func encrypt(data: Data, with key: SymmetricKey) throws -> Data {
           do {
               let sealedBox = try AES.GCM.seal(data, using: key)
               return sealedBox.combined!
           } catch {
               throw EncryptionError.encryptionFailed
           }
       }
       
       public static func decrypt(sealedData: Data, with key: SymmetricKey) throws -> Data {
           do {
               let sealedBox = try AES.GCM.SealedBox(combined: sealedData)
               return try AES.GCM.open(sealedBox, using: key)
           } catch {
               throw EncryptionError.decryptionFailed
           }
       }
       
       public static func generateKey() -> SymmetricKey {
           return SymmetricKey(size: .bits256)
       }
       
       // 해시 함수
       public static func sha256Hash(of data: Data) -> String {
           let hash = SHA256.hash(data: data)
           return hash.compactMap { String(format: "%02x", $0) }.joined()
       }
   }
   ```

2. **헬퍼 클래스 구현**
   ```swift
   // UtilsModule/Sources/Helpers/KeychainHelper.swift
   import Foundation
   import Security
   
   public enum KeychainError: Error {
       case itemNotFound
       case duplicateItem
       case unexpectedStatus(OSStatus)
   }
   
   public final class KeychainHelper {
       private let service: String
       
       public init(service: String) {
           self.service = service
       }
       
       public func save(_ data: Data, forKey key: String) throws {
           let query: [String: Any] = [
               kSecClass as String: kSecClassGenericPassword,
               kSecAttrService as String: service,
               kSecAttrAccount as String: key,
               kSecValueData as String: data
           ]
           
           // 기존 항목 삭제 시도
           SecItemDelete(query as CFDictionary)
           
           let status = SecItemAdd(query as CFDictionary, nil)
           guard status == errSecSuccess else {
               throw KeychainError.unexpectedStatus(status)
           }
       }
       
       public func load(forKey key: String) throws -> Data {
           let query: [String: Any] = [
               kSecClass as String: kSecClassGenericPassword,
               kSecAttrService as String: service,
               kSecAttrAccount as String: key,
               kSecReturnData as String: true
           ]
           
           var result: AnyObject?
           let status = SecItemCopyMatching(query as CFDictionary, &result)
           
           guard status == errSecSuccess else {
               if status == errSecItemNotFound {
                   throw KeychainError.itemNotFound
               }
               throw KeychainError.unexpectedStatus(status)
           }
           
           guard let data = result as? Data else {
               throw KeychainError.unexpectedStatus(errSecInternalError)
           }
           
           return data
       }
       
       public func delete(forKey key: String) throws {
           let query: [String: Any] = [
               kSecClass as String: kSecClassGenericPassword,
               kSecAttrService as String: service,
               kSecAttrAccount as String: key
           ]
           
           let status = SecItemDelete(query as CFDictionary)
           
           guard status == errSecSuccess || status == errSecItemNotFound else {
               throw KeychainError.unexpectedStatus(status)
           }
       }
   }
   ```

3. **단위 테스트 작성**
   ```swift
   // UtilsModuleTests/Extensions/StringExtensionsTests.swift
   import XCTest
   @testable import UtilsModule
   
   final class StringExtensionsTests: XCTestCase {
       func testMaskedString() {
           let cardNumber = "1234567890123456"
           let masked = cardNumber.masked(start: 4, end: 12, mask: "*")
           XCTAssertEqual(masked, "1234********3456")
       }
       
       func testIsValidEmail() {
           XCTAssertTrue("test@example.com".isValidEmail())
           XCTAssertFalse("test@example".isValidEmail())
           XCTAssertFalse("test".isValidEmail())
           XCTAssertFalse("".isValidEmail())
       }
       
       func testTrimmed() {
           XCTAssertEqual("  hello  ".trimmed(), "hello")
           XCTAssertEqual("hello".trimmed(), "hello")
           XCTAssertEqual("  ".trimmed(), "")
       }
   }
   ```

### 4-2: Analytics 모듈 구축 (1주)

#### 8-9일차: 분석 및 로깅 인프라 설계
1. **모듈 구조 설계**
   ```
   Analytics/
     ├── Sources/
     │   ├── Core/
     │   ├── Events/
     │   ├── Loggers/
     │   ├── Trackers/
     │   └── Providers/
     ├── Tests/
     └── Resources/
   ```

2. **핵심 인터페이스 정의**
   ```swift
   // AnalyticsModule/Sources/Core/AnalyticsEvent.swift
   import Foundation
   
   public protocol AnalyticsEvent {
       var name: String { get }
       var parameters: [String: Any]? { get }
       var timestamp: Date { get }
   }
   
   public struct DefaultAnalyticsEvent: AnalyticsEvent {
       public let name: String
       public let parameters: [String: Any]?
       public let timestamp: Date
       
       public init(name: String, parameters: [String: Any]? = nil, timestamp: Date = Date()) {
           self.name = name
           self.parameters = parameters
           self.timestamp = timestamp
       }
   }
   
   // AnalyticsModule/Sources/Core/AnalyticsProvider.swift
   import Foundation
   
   public protocol AnalyticsProvider {
       var id: String { get }
       
       func initialize()
       func trackEvent(_ event: AnalyticsEvent)
       func setUserProperty(key: String, value: Any)
       func setUserId(_ userId: String)
       func reset()
   }
   ```

3. **모듈 구성도 작성**
   ```markdown
   # Analytics 모듈 구조
   
   ## 개요
   Analytics 모듈은 앱 사용 패턴, 사용자 행동, 성능 측정 데이터를 수집하고 분석하기 위한 인프라를 제공합니다.
   
   ## 주요 컴포넌트
   1. **Core**: 핵심 인터페이스 및 추상화 정의
   2. **Events**: 표준 이벤트 정의
   3. **Loggers**: 로깅 시스템
   4. **Trackers**: 이벤트 추적 메커니즘
   5. **Providers**: 분석 서비스 제공자(Firebase, Amplitude 등) 어댑터
   
   ## 주요 인터페이스
   - AnalyticsEvent: 추적 가능한 이벤트 인터페이스
   - AnalyticsProvider: 분석 서비스 제공자 인터페이스
   - AnalyticsManager: 중앙 분석 관리자
   - Logger: 로깅 시스템 인터페이스
   ```

#### 10-11일차: 이벤트 추적 시스템 구현
1. **표준 이벤트 정의**
   ```swift
   // AnalyticsModule/Sources/Events/StandardEvents.swift
   import Foundation
   
   public extension DefaultAnalyticsEvent {
       // 화면 조회 이벤트
       static func screenView(screenName: String, screenClass: String? = nil) -> DefaultAnalyticsEvent {
           var params: [String: Any] = ["screen_name": screenName]
           if let screenClass = screenClass {
               params["screen_class"] = screenClass
           }
           return DefaultAnalyticsEvent(name: "screen_view", parameters: params)
       }
       
       // 버튼 탭 이벤트
       static func buttonTap(buttonName: String, screenName: String) -> DefaultAnalyticsEvent {
           return DefaultAnalyticsEvent(
               name: "button_tap",
               parameters: ["button_name": buttonName, "screen_name": screenName]
           )
       }
       
       // 로그인 이벤트
       static func login(method: String) -> DefaultAnalyticsEvent {
           return DefaultAnalyticsEvent(
               name: "login",
               parameters: ["method": method]
           )
       }
       
       // 계좌 조회 이벤트
       static func accountView(accountType: String, isFirstView: Bool) -> DefaultAnalyticsEvent {
           return DefaultAnalyticsEvent(
               name: "account_view",
               parameters: ["account_type": accountType, "is_first_view": isFirstView]
           )
       }
       
       // 송금 이벤트
       static func transfer(amount: Decimal, isSuccessful: Bool) -> DefaultAnalyticsEvent {
           return DefaultAnalyticsEvent(
               name: "transfer",
               parameters: ["amount": amount, "is_successful": isSuccessful]
           )
       }
       
       // 앱 성능 이벤트
       static func performance(metric: String, value: Double) -> DefaultAnalyticsEvent {
           return DefaultAnalyticsEvent(
               name: "performance",
               parameters: ["metric": metric, "value": value]
           )
       }
       
       // 오류 이벤트
       static func error(code: String, message: String, domain: String) -> DefaultAnalyticsEvent {
           return DefaultAnalyticsEvent(
               name: "error",
               parameters: ["error_code": code, "error_message": message, "error_domain": domain]
           )
       }
   }
   ```

2. **분석 관리자 구현**
   ```swift
   // AnalyticsModule/Sources/Core/AnalyticsManager.swift
   import Foundation
   import OSLog
   
   public final class AnalyticsManager {
       private var providers: [AnalyticsProvider] = []
       private let logger = Logger(subsystem: "com.tossbankclone", category: "Analytics")
       
       public static let shared = AnalyticsManager()
       
       private init() {}
       
       public func registerProvider(_ provider: AnalyticsProvider) {
           if !providers.contains(where: { $0.id == provider.id }) {
               providers.append(provider)
               provider.initialize()
               logger.debug("Registered analytics provider: \(provider.id)")
           }
       }
       
       public func unregisterProvider(withId id: String) {
           providers.removeAll { $0.id == id }
           logger.debug("Unregistered analytics provider: \(id)")
       }
       
       public func trackEvent(_ event: AnalyticsEvent) {
           providers.forEach { $0.trackEvent(event) }
           logger.debug("Tracked event: \(event.name)")
       }
       
       public func setUserProperty(key: String, value: Any) {
           providers.forEach { $0.setUserProperty(key: key, value: value) }
       }
       
       public func setUserId(_ userId: String) {
           providers.forEach { $0.setUserId(userId) }
       }
       
       public func reset() {
           providers.forEach { $0.reset() }
       }
   }
   ```

3. **제공자 구현**
   ```swift
   // AnalyticsModule/Sources/Providers/FirebaseAnalyticsProvider.swift
   import Foundation
   
   public final class FirebaseAnalyticsProvider: AnalyticsProvider {
       public let id = "firebase"
       
       public init() {}
       
       public func initialize() {
           // Firebase SDK 초기화 코드
           // 실제 구현에서는 Firebase SDK를 사용
           print("Firebase Analytics initialized")
       }
       
       public func trackEvent(_ event: AnalyticsEvent) {
           // Firebase에 이벤트 전송 코드
           // 실제 구현에서는 Firebase SDK를 사용
           print("Firebase: Tracked event \(event.name) with params: \(event.parameters ?? [:])")
       }
       
       public func setUserProperty(key: String, value: Any) {
           // Firebase에 사용자 속성 설정 코드
           print("Firebase: Set user property \(key) = \(value)")
       }
       
       public func setUserId(_ userId: String) {
           // Firebase에 사용자 ID 설정 코드
           print("Firebase: Set user ID to \(userId)")
       }
       
       public func reset() {
           // Firebase 사용자 데이터 초기화 코드
           print("Firebase: Reset user data")
       }
   }
   ```

#### 12-14일차: 앱 성능 모니터링 체계 구축
1. **성능 모니터링 시스템 구현**
   ```swift
   // AnalyticsModule/Sources/Core/PerformanceMonitor.swift
   import Foundation
   import OSLog
   
   public final class PerformanceMonitor {
       public static let shared = PerformanceMonitor()
       
       private let analyticsManager = AnalyticsManager.shared
       private let logger = Logger(subsystem: "com.tossbankclone", category: "Performance")
       private var timers: [String: CFAbsoluteTime] = [:]
       
       private init() {}
       
       public func startTimer(identifier: String) {
           timers[identifier] = CFAbsoluteTimeGetCurrent()
           logger.debug("Started timer: \(identifier)")
       }
       
       public func stopTimer(identifier: String) {
           guard let startTime = timers[identifier] else {
               logger.error("Timer not found: \(identifier)")
               return
           }
           
           let endTime = CFAbsoluteTimeGetCurrent()
           let elapsedTime = endTime - startTime
           
           timers.removeValue(forKey: identifier)
           
           // 성능 이벤트 전송
           let event = DefaultAnalyticsEvent.performance(
               metric: identifier,
               value: elapsedTime * 1000 // 밀리초 단위로 변환
           )
           analyticsManager.trackEvent(event)
           
           logger.debug("Timer \(identifier) stopped: \(elapsedTime * 1000, privacy: .public) ms")
       }
       
       public func recordMemoryUsage() {
           var info = mach_task_basic_info()
           var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size) / 4
           
           let kerr = withUnsafeMutablePointer(to: &info) {
               $0.withMemoryRebound(to: integer_t.self, capacity: Int(count)) {
                   task_info(mach_task_self_, task_flavor_t(MACH_TASK_BASIC_INFO), $0, &count)
               }
           }
           
           if kerr == KERN_SUCCESS {
               let usedMemoryMB = Double(info.resident_size) / (1024 * 1024)
               
               // 메모리 사용량 이벤트 전송
               let event = DefaultAnalyticsEvent.performance(
                   metric: "memory_usage",
                   value: usedMemoryMB
               )
               analyticsManager.trackEvent(event)
               
               logger.debug("Memory usage: \(usedMemoryMB, privacy: .public) MB")
           }
       }
       
       public func recordCPUUsage() {
           var threadList: thread_act_array_t?
           var threadCount: mach_msg_type_number_t = 0
           
           let kerr = task_threads(mach_task_self_, &threadList, &threadCount)
           
           if kerr == KERN_SUCCESS, let threadList = threadList {
               var totalCPU: Double = 0
               
               for i in 0..<Int(threadCount) {
                   var threadInfo = thread_basic_info()
                   var count = mach_msg_type_number_t(THREAD_BASIC_INFO_COUNT)
                   
                   let err = withUnsafeMutablePointer(to: &threadInfo) {
                       $0.withMemoryRebound(to: integer_t.self, capacity: Int(count)) {
                           thread_info(threadList[i], thread_flavor_t(THREAD_BASIC_INFO), $0, &count)
                       }
                   }
                   
                   if err == KERN_SUCCESS {
                       let cpuUsage = Double(threadInfo.cpu_usage) / Double(TH_USAGE_SCALE) * 100.0
                       totalCPU += cpuUsage
                   }
               }
               
               // CPU 사용량 이벤트 전송
               let event = DefaultAnalyticsEvent.performance(
                   metric: "cpu_usage",
                   value: totalCPU
               )
               analyticsManager.trackEvent(event)
               
               logger.debug("CPU usage: \(totalCPU, privacy: .public)%")
               
               // 스레드 리스트 해제
               vm_deallocate(mach_task_self_, vm_address_t(UnsafePointer(threadList).pointee), vm_size_t(threadCount * MemoryLayout<thread_act_t>.size))
           }
       }
   }
   ```

2. **로거 구현**
   ```swift
   // AnalyticsModule/Sources/Loggers/AppLogger.swift
   import Foundation
   import OSLog
   
   public enum LogLevel: Int {
       case debug = 0
       case info = 1
       case warning = 2
       case error = 3
       case critical = 4
   }
   
   public final class AppLogger {
       private let category: String
       private let logger: Logger
       private let analyticsManager = AnalyticsManager.shared
       private let minLogLevel: LogLevel
       
       public init(category: String, minLogLevel: LogLevel = .debug) {
           self.category = category
           self.minLogLevel = minLogLevel
           self.logger = Logger(subsystem: "com.tossbankclone", category: category)
       }
       
       public func debug(_ message: String, file: String = #file, function: String = #function, line: Int = #line) {
           guard minLogLevel.rawValue <= LogLevel.debug.rawValue else { return }
           logger.debug("\(message) [\(sourceInfo(file: file, function: function, line: line))]")
       }
       
       public func info(_ message: String, file: String = #file, function: String = #function, line: Int = #line) {
           guard minLogLevel.rawValue <= LogLevel.info.rawValue else { return }
           logger.info("\(message) [\(sourceInfo(file: file, function: function, line: line))]")
       }
       
       public func warning(_ message: String, file: String = #file, function: String = #function, line: Int = #line) {
           guard minLogLevel.rawValue <= LogLevel.warning.rawValue else { return }
           logger.warning("\(message) [\(sourceInfo(file: file, function: function, line: line))]")
       }
       
       public func error(_ message: String, error: Error? = nil, file: String = #file, function: String = #function, line: Int = #line) {
           guard minLogLevel.rawValue <= LogLevel.error.rawValue else { return }
           
           let errorMessage = error != nil ? "\(message): \(error!.localizedDescription)" : message
           logger.error("\(errorMessage) [\(sourceInfo(file: file, function: function, line: line))]")
           
           // 오류 이벤트 전송
           if let error = error {
               let nsError = error as NSError
               let event = DefaultAnalyticsEvent.error(
                   code: String(nsError.code),
                   message: nsError.localizedDescription,
                   domain: nsError.domain
               )
               analyticsManager.trackEvent(event)
           }
       }
       
       public func critical(_ message: String, error: Error? = nil, file: String = #file, function: String = #function, line: Int = #line) {
           guard minLogLevel.rawValue <= LogLevel.critical.rawValue else { return }
           
           let errorMessage = error != nil ? "\(message): \(error!.localizedDescription)" : message
           logger.critical("\(errorMessage) [\(sourceInfo(file: file, function: function, line: line))]")
           
           // 심각한 오류 이벤트 전송
           if let error = error {
               let nsError = error as NSError
               let event = DefaultAnalyticsEvent.error(
                   code: String(nsError.code),
                   message: nsError.localizedDescription,
                   domain: nsError.domain
               )
               analyticsManager.trackEvent(event)
           }
       }
       
       private func sourceInfo(file: String, function: String, line: Int) -> String {
           let fileName = URL(fileURLWithPath: file).lastPathComponent
           return "\(fileName):\(line) \(function)"
       }
   }
   ```

3. **화면 추적 유틸리티 구현**
   ```swift
   // AnalyticsModule/Sources/Trackers/ScreenTracker.swift
   import UIKit
   import SwiftUI
   
   public final class ScreenTracker {
       private let analyticsManager = AnalyticsManager.shared
       
       public static let shared = ScreenTracker()
       
       private init() {
           setupNotifications()
       }
       
       private func setupNotifications() {
           NotificationCenter.default.addObserver(
               self,
               selector: #selector(viewControllerDidAppear),
               name: UIViewController.didAppearNotification,
               object: nil
           )
       }
       
       @objc private func viewControllerDidAppear(_ notification: Notification) {
           guard let viewController = notification.object as? UIViewController else { return }
           trackScreen(name: String(describing: type(of: viewController)))
       }
       
       public func trackScreen(name: String, parameters: [String: Any]? = nil) {
           var eventParams = parameters ?? [:]
           eventParams["screen_name"] = name
           
           let event = DefaultAnalyticsEvent(
               name: "screen_view",
               parameters: eventParams
           )
           analyticsManager.trackEvent(event)
       }
   }
   
   // SwiftUI용 화면 추적 수정자
   public struct ScreenTrackingViewModifier: ViewModifier {
       let screenName: String
       let parameters: [String: Any]?
       
       public init(screenName: String, parameters: [String: Any]? = nil) {
           self.screenName = screenName
           self.parameters = parameters
       }
       
       public func body(content: Content) -> some View {
           content.onAppear {
               ScreenTracker.shared.trackScreen(name: screenName, parameters: parameters)
           }
       }
   }
   
   public extension View {
       func trackScreen(name: String, parameters: [String: Any]? = nil) -> some View {
           modifier(ScreenTrackingViewModifier(screenName: name, parameters: parameters))
       }
   }
   ```

### 4-3: Testing 모듈 개발 (1주)

#### 15-16일차: 테스트 헬퍼 클래스 구현
1. **모듈 구조 설계**
   ```
   Testing/
     ├── Sources/
     │   ├── Mocks/
     │   ├── Stubs/
     │   ├── Fixtures/
     │   ├── Helpers/
     │   └── Extensions/
     └── Resources/
   ```

2. **테스트 데이터 생성기 구현**
   ```swift
   // TestingModule/Sources/Fixtures/TestDataFactory.swift
   import Foundation
   import DomainModule
   
   public final class TestDataFactory {
       // 사용자 테스트 데이터
       public static func createTestUser(id: String = "user123") -> User {
           return User(
               id: id,
               name: "테스트 사용자",
               email: "test@example.com",
               phoneNumber: "010-1234-5678",
               createdAt: Date().addingTimeInterval(-86400 * 30) // 30일 전
           )
       }
       
       // 계좌 테스트 데이터
       public static func createTestAccount(
           id: String = "account123",
           type: AccountType = .checking,
           balance: Decimal = 1000000
       ) -> Account {
           return Account(
               id: id,
               name: "\(type.displayName) 계좌",
               type: type,
               balance: balance,
               currency: .krw,
               isActive: true,
               createdAt: Date().addingTimeInterval(-86400 * 30) // 30일 전
           )
       }
       
       // 거래내역 테스트 데이터
       public static func createTestTransaction(
           id: String = "transaction123",
           accountId: String = "account123",
           amount: Decimal = 10000,
           isOutgoing: Bool = true,
           date: Date = Date().addingTimeInterval(-86400) // 1일 전
       ) -> Transaction {
           return Transaction(
               id: id,
               accountId: accountId,
               type: isOutgoing ? .withdraw : .deposit,
               amount: amount,
               balance: isOutgoing ? 1000000 - amount : 1000000 + amount,
               currency: .krw,
               description: isOutgoing ? "테스트 출금" : "테스트 입금",
               counterParty: isOutgoing ? "테스트 가맹점" : "테스트 송금자",
               date: date
           )
       }
       
       // 여러 계좌 생성
       public static func createTestAccounts(count: Int = 3) -> [Account] {
           let types: [AccountType] = [.checking, .savings, .investment]
           
           return (0..<count).map { i in
               let type = types[i % types.count]
               return createTestAccount(
                   id: "account\(i+1)",
                   type: type,
                   balance: Decimal(100000 * (i+1))
               )
           }
       }
       
       // 여러 거래내역 생성
       public static func createTestTransactions(
           count: Int = 10,
           accountId: String = "account123"
       ) -> [Transaction] {
           return (0..<count).map { i in
               let isOutgoing = i % 2 == 0
               let date = Date().addingTimeInterval(-Double(i * 86400)) // i일 전
               
               return createTestTransaction(
                   id: "transaction\(i+1)",
                   accountId: accountId,
                   amount: Decimal(1000 * (i+1)),
                   isOutgoing: isOutgoing,
                   date: date
               )
           }
       }
   }
   ```

3. **테스트 유틸리티 구현**
   ```swift
   // TestingModule/Sources/Helpers/AsyncTestHelper.swift
   import Foundation
   import XCTest
   
   public final class AsyncTestHelper {
       private let timeoutInterval: TimeInterval
       
       public init(timeoutInterval: TimeInterval = 5.0) {
           self.timeoutInterval = timeoutInterval
       }
       
       public func wait<T>(for expression: @escaping () async throws -> T) async throws -> T {
           let expectation = XCTestExpectation(description: "Async operation")
           
           var result: Result<T, Error>?
           
           Task {
               do {
                   let value = try await expression()
                   result = .success(value)
               } catch {
                   result = .failure(error)
               }
               expectation.fulfill()
           }
           
           let waiter = XCTWaiter()
           let result = waiter.wait(for: [expectation], timeout: timeoutInterval)
           
           switch result {
           case .completed:
               if let actualResult = result {
                   switch actualResult {
                   case .success(let value):
                       return value
                   case .failure(let error):
                       throw error
                   }
               } else {
                   throw NSError(domain: "AsyncTestHelper", code: -1, userInfo: [NSLocalizedDescriptionKey: "No result was set"])
               }
           case .timedOut:
               throw NSError(domain: "AsyncTestHelper", code: -2, userInfo: [NSLocalizedDescriptionKey: "Operation timed out"])
           default:
               throw NSError(domain: "AsyncTestHelper", code: -3, userInfo: [NSLocalizedDescriptionKey: "Wait interrupted"])
           }
       }
   }
   ```

#### 17-18일차: 테스트용 모의 객체 및 데이터 팩토리 개발
1. **네트워크 모의 객체 구현**
   ```swift
   // TestingModule/Sources/Mocks/MockNetworkClient.swift
   import Foundation
   import NetworkModule
   
   public final class MockNetworkClient: NetworkClient {
       public struct Response {
           let data: Data
           let statusCode: Int
           let error: Error?
           
           public init(data: Data = Data(), statusCode: Int = 200, error: Error? = nil) {
               self.data = data
               self.statusCode = statusCode
               self.error = error
           }
           
           public static func success<T: Encodable>(with object: T) -> Response {
               let data = try! JSONEncoder().encode(object)
               return Response(data: data, statusCode: 200)
           }
           
           public static func failure(statusCode: Int = 400, error: Error? = nil) -> Response {
               return Response(statusCode: statusCode, error: error)
           }
       }
       
       public var responseByEndpoint: [String: Response] = [:]
       public var requestLog: [(endpoint: Endpoint, timestamp: Date)] = []
       
       public init() {}
       
       public func register(endpoint: Endpoint, response: Response) {
           let key = key(for: endpoint)
           responseByEndpoint[key] = response
       }
       
       public func request<T: Decodable>(_ endpoint: Endpoint) async throws -> T {
           let key = key(for: endpoint)
           requestLog.append((endpoint: endpoint, timestamp: Date()))
           
           guard let response = responseByEndpoint[key] else {
               throw NetworkError.invalidRequest
           }
           
           if let error = response.error {
               throw error
           }
           
           if response.statusCode < 200 || response.statusCode >= 300 {
               throw NetworkError.httpError(statusCode: response.statusCode, data: response.data)
           }
           
           do {
               return try JSONDecoder().decode(T.self, from: response.data)
           } catch {
               throw NetworkError.decodingError(error)
           }
       }
       
       public func upload<T: Decodable>(data: Data, to endpoint: Endpoint) async throws -> T {
           return try await request(endpoint)
       }
       
       public func download(from endpoint: Endpoint) async throws -> URL {
           let key = key(for: endpoint)
           requestLog.append((endpoint: endpoint, timestamp: Date()))
           
           guard let response = responseByEndpoint[key] else {
               throw NetworkError.invalidRequest
           }
           
           if let error = response.error {
               throw error
           }
           
           let tempURL = URL(fileURLWithPath: NSTemporaryDirectory()).appendingPathComponent(UUID().uuidString)
           try response.data.write(to: tempURL)
           return tempURL
       }
       
       private func key(for endpoint: Endpoint) -> String {
           return "\(endpoint.baseURL.absoluteString)\(endpoint.path)_\(endpoint.method.rawValue)"
       }
   }
   ```

2. **데이터베이스 모의 객체 구현**
   ```swift
   // TestingModule/Sources/Mocks/MockDatabaseManager.swift
   import Foundation
   import DatabaseModule
   
   public final class MockDatabaseManager: DatabaseManagerProtocol {
       public var storedItems: [String: Any] = [:]
       public var operationLog: [(operation: String, key: String, timestamp: Date)] = []
       
       public init() {}
       
       public func save<T: PersistentModel>(_ item: T) async throws {
           let key = String(describing: type(of: T.self)) + "/" + item.id
           storedItems[key] = item
           operationLog.append((operation: "save", key: key, timestamp: Date()))
       }
       
       public func fetch<T: PersistentModel>(_ type: T.Type, predicate: Predicate<T>?) async throws -> [T] {
           let prefix = String(describing: type)
           let result = storedItems.compactMap { key, value -> T? in
               guard key.hasPrefix(prefix), let item = value as? T else { return nil }
               
               // 매우 단순한 predicate 처리 (실제 구현에서는 더 복잡할 것)
               if let predicate = predicate {
                   // 여기서는 실제 predicate 평가 로직이 복잡하므로 간단하게 처리
                   return item
               }
               
               return item
           }
           
           operationLog.append((operation: "fetch", key: prefix, timestamp: Date()))
           return result
       }
       
       public func delete<T: PersistentModel>(_ item: T) async throws {
           let key = String(describing: type(of: T.self)) + "/" + item.id
           storedItems.removeValue(forKey: key)
           operationLog.append((operation: "delete", key: key, timestamp: Date()))
       }
   }
   ```

3. **저장소 모의 객체 구현**
   ```swift
   // TestingModule/Sources/Mocks/MockAccountRepository.swift
   import Foundation
   import DomainModule
   
   public final class MockAccountRepository: AccountRepository {
       public var accounts: [Account] = []
       public var transactions: [Transaction] = []
       public var shouldThrowError = false
       public var error: Error = NSError(domain: "MockError", code: -1, userInfo: nil)
       
       public init(accounts: [Account] = [], transactions: [Transaction] = []) {
           self.accounts = accounts
           self.transactions = transactions
       }
       
       public func getAccounts() async throws -> [Account] {
           if shouldThrowError {
               throw error
           }
           return accounts
       }
       
       public func getAccount(id: String) async throws -> Account {
           if shouldThrowError {
               throw error
           }
           
           guard let account = accounts.first(where: { $0.id == id }) else {
               throw DomainError.entityNotFound
           }
           
           return account
       }
       
       public func getTransactions(accountId: String, limit: Int?, offset: Int?) async throws -> [Transaction] {
           if shouldThrowError {
               throw error
           }
           
           var filteredTransactions = transactions.filter { $0.accountId == accountId }
           
           if let offset = offset, offset < filteredTransactions.count {
               filteredTransactions = Array(filteredTransactions.dropFirst(offset))
           }
           
           if let limit = limit, limit < filteredTransactions.count {
               filteredTransactions = Array(filteredTransactions.prefix(limit))
           }
           
           return filteredTransactions
       }
       
       public func addAccount(_ account: Account) async throws {
           if shouldThrowError {
               throw error
           }
           
           if accounts.contains(where: { $0.id == account.id }) {
               accounts = accounts.map { $0.id == account.id ? account : $0 }
           } else {
               accounts.append(account)
           }
       }
       
       public func deleteAccount(id: String) async throws {
           if shouldThrowError {
               throw error
           }
           
           guard accounts.contains(where: { $0.id == id }) else {
               throw DomainError.entityNotFound
           }
           
           accounts.removeAll { $0.id == id }
           transactions.removeAll { $0.accountId == id }
       }
   }
   ```

#### 19-21일차: UI 테스트 유틸리티 구성
1. **UI 테스트 헬퍼 구현**
   ```swift
   // TestingModule/Sources/Helpers/UITestHelper.swift
   import Foundation
   import XCTest
   
   public final class UITestHelper {
       private let app: XCUIApplication
       
       public init(app: XCUIApplication) {
           self.app = app
       }
       
       public func launchApp(arguments: [String] = []) {
           app.launchArguments += arguments
           app.launchArguments += ["--UITesting"]
           app.launch()
       }
       
       public func tapButton(identifier: String, timeout: TimeInterval = 5.0) -> Bool {
           let button = app.buttons[identifier]
           return waitForElementAndTap(element: button, timeout: timeout)
       }
       
       public func tapCell(identifier: String, timeout: TimeInterval = 5.0) -> Bool {
           let cell = app.cells[identifier]
           return waitForElementAndTap(element: cell, timeout: timeout)
       }
       
       public func enterText(_ text: String, in identifier: String, timeout: TimeInterval = 5.0) -> Bool {
           let textField = app.textFields[identifier]
           
           guard waitForElement(element: textField, timeout: timeout) else {
               return false
           }
           
           textField.tap()
           textField.typeText(text)
           return true
       }
       
       public func waitForText(_ text: String, timeout: TimeInterval = 5.0) -> Bool {
           let predicate = NSPredicate(format: "label CONTAINS %@", text)
           let elementQuery = app.staticTexts.containing(predicate)
           
           return waitForElement(element: elementQuery.element, timeout: timeout)
       }
       
       public func screenshot(name: String) {
           let screenshot = app.screenshot()
           let attachment = XCTAttachment(screenshot: screenshot)
           attachment.name = name
           attachment.lifetime = .keepAlways
           XCTContext.runActivity(named: "Take screenshot \(name)") { activity in
               activity.add(attachment)
           }
       }
       
       private func waitForElement(element: XCUIElement, timeout: TimeInterval) -> Bool {
           return element.waitForExistence(timeout: timeout)
       }
       
       private func waitForElementAndTap(element: XCUIElement, timeout: TimeInterval) -> Bool {
           guard waitForElement(element: element, timeout: timeout) else {
               return false
           }
           
           element.tap()
           return true
       }
   }
   ```

2. **테스트 라우팅 유틸리티 구현**
   ```swift
   // TestingModule/Sources/Helpers/UITestRouting.swift
   import Foundation
   import XCTest
   
   public final class UITestRouting {
       private let helper: UITestHelper
       
       public init(app: XCUIApplication) {
           self.helper = UITestHelper(app: app)
       }
       
       public func goToLogin() {
           helper.launchApp(arguments: ["--reset-state"])
       }
       
       public func login(username: String, password: String) -> Bool {
           guard helper.enterText(username, in: "usernameTextField") else { return false }
           guard helper.enterText(password, in: "passwordTextField") else { return false }
           return helper.tapButton(identifier: "loginButton")
       }
       
       public func goToAccountList() -> Bool {
           return helper.tapButton(identifier: "accountsTabButton")
       }
       
       public func goToAccountDetail(at index: Int) -> Bool {
           guard goToAccountList() else { return false }
           return helper.tapCell(identifier: "accountCell_\(index)")
       }
       
       public func goToTransfer() -> Bool {
           return helper.tapButton(identifier: "transferTabButton")
       }
       
       public func goToSettings() -> Bool {
           return helper.tapButton(identifier: "settingsTabButton")
       }
       
       public func logout() -> Bool {
           guard goToSettings() else { return false }
           helper.screenshot("BeforeLogout")
           return helper.tapButton(identifier: "logoutButton")
       }
   }
   ```

3. **테스트 데이터 제공자 구현**
   ```swift
   // TestingModule/Sources/Fixtures/UITestDataProvider.swift
   import Foundation
   
   public final class UITestDataProvider {
       public static func setupTestData(for scenario: TestScenario) -> [String: Any] {
           switch scenario {
           case .emptyState:
               return [
                   "accounts": [],
                   "transactions": []
               ]
               
           case .singleAccount:
               return [
                   "accounts": [
                       [
                           "id": "account1",
                           "name": "테스트 계좌",
                           "type": "checking",
                           "balance": 1000000,
                           "currency": "KRW",
                           "isActive": true
                       ]
                   ],
                   "transactions": []
               ]
               
           case .multipleAccounts:
               return [
                   "accounts": [
                       [
                           "id": "account1",
                           "name": "입출금 계좌",
                           "type": "checking",
                           "balance": 1000000,
                           "currency": "KRW",
                           "isActive": true
                       ],
                       [
                           "id": "account2",
                           "name": "적금 계좌",
                           "type": "savings",
                           "balance": 5000000,
                           "currency": "KRW",
                           "isActive": true
                       ],
                       [
                           "id": "account3",
                           "name": "투자 계좌",
                           "type": "investment",
                           "balance": 10000000,
                           "currency": "KRW",
                           "isActive": true
                       ]
                   ],
                   "transactions": []
               ]
               
           case .withTransactions:
               return [
                   "accounts": [
                       [
                           "id": "account1",
                           "name": "입출금 계좌",
                           "type": "checking",
                           "balance": 1000000,
                           "currency": "KRW",
                           "isActive": true
                       ]
                   ],
                   "transactions": [
                       [
                           "id": "tx1",
                           "accountId": "account1",
                           "type": "withdraw",
                           "amount": 50000,
                           "balance": 950000,
                           "description": "테스트 출금",
                           "counterParty": "테스트 가맹점",
                           "currency": "KRW"
                       ],
                       [
                           "id": "tx2",
                           "accountId": "account1",
                           "type": "deposit",
                           "amount": 100000,
                           "balance": 1050000,
                           "description": "테스트 입금",
                           "counterParty": "테스트 송금자",
                           "currency": "KRW"
                       ]
                   ]
               ]
           }
       }
       
       public enum TestScenario {
           case emptyState
           case singleAccount
           case multipleAccounts
           case withTransactions
       }
   }
   ```

## 4단계 산출물 체크리스트

- [ ] Utils 모듈 생성 및 기본 유틸리티 구현 완료
- [ ] 공통 확장 기능 통합 완료
- [ ] 표준 유틸리티 라이브러리 구성 완료
- [ ] Analytics 모듈 구현 및 이벤트 추적 시스템 구축 완료
- [ ] 앱 성능 모니터링 체계 구축 완료
- [ ] Testing 모듈 개발 및 테스트 헬퍼/모의 객체 구현 완료
- [ ] UI 테스트 유틸리티 구성 완료
- [ ] 모든 변경사항에 대한 단위 테스트 작성 완료
- [ ] 4단계 완료 보고서 및 5단계 세부 계획

이 4단계 실행 계획을 통해 주요 플랫폼 모듈을 구축하고, 아키텍처 문서에 제시된 플랫폼 모듈을 실제로 구현할 수 있습니다. 이 모듈들은 기능 모듈과 코어 모듈에서 공통적으로 활용되어 코드 재사용성과 일관성을 높이는 데 기여할 것입니다.
