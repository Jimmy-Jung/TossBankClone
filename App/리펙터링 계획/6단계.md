
# 토스뱅크 클론 프로젝트 리팩터링 6단계 실행 계획

## 6단계: 최종 검증 및 문서화 (1주)

### 6-1: 성능 및 품질 검증 (3일)

#### 1일차: 메모리 누수 검사
1. **메모리 사용량 프로파일링**
   ```bash
   # Instruments를 이용한 메모리 누수 검사 실행
   xctrace record --template 'Leaks' --launch TossBankClone --output memory_profile.trace
   ```

2. **메모리 누수 수정 프로세스**
   ```swift
   // 약한 참조로 변경 예시 - 순환 참조 방지
   // 기존 코드
   private let viewModel: AccountDetailViewModel
   
   // 수정된 코드
   private weak var viewModel: AccountDetailViewModel?
   ```

3. **자동화된 메모리 검사 도구 구현**
   ```swift
   // TestingModule/Sources/Helpers/MemoryLeakDetector.swift
   import Foundation
   import XCTest
   
   public final class MemoryLeakDetector {
       public static func checkForLeaks(_ instance: AnyObject, file: StaticString = #file, line: UInt = #line) {
           addTeardownBlock { [weak instance] in
               XCTAssertNil(instance, "잠재적 메모리 누수 감지. 인스턴스가 해제되지 않음", file: file, line: line)
           }
       }
   }
   ```

#### 2일차: UI 렌더링 성능 측정
1. **UI 성능 측정 설정**
   ```swift
   // AnalyticsModule/Sources/Core/UIPerformanceMonitor.swift
   import Foundation
   import UIKit
   import QuartzCore
   
   public final class UIPerformanceMonitor {
       public static let shared = UIPerformanceMonitor()
       
       private var displayLink: CADisplayLink?
       private var frameData: [CFTimeInterval] = []
       private let maxDataPoints = 60
       private var lastFrameTimestamp: CFTimeInterval = 0
       
       private init() {}
       
       public func startMonitoring() {
           displayLink = CADisplayLink(target: self, selector: #selector(displayLinkDidFire))
           displayLink?.add(to: .main, forMode: .common)
       }
       
       public func stopMonitoring() {
           displayLink?.invalidate()
           displayLink = nil
       }
       
       @objc private func displayLinkDidFire(_ displayLink: CADisplayLink) {
           if lastFrameTimestamp == 0 {
               lastFrameTimestamp = displayLink.timestamp
               return
           }
           
           let elapsed = displayLink.timestamp - lastFrameTimestamp
           lastFrameTimestamp = displayLink.timestamp
           
           frameData.append(elapsed)
           if frameData.count > maxDataPoints {
               frameData.removeFirst()
           }
       }
       
       public func getCurrentFPS() -> Double {
           guard !frameData.isEmpty else { return 0 }
           
           let averageFrameTime = frameData.reduce(0, +) / Double(frameData.count)
           return 1.0 / averageFrameTime
       }
       
       public func getPerformanceReport() -> PerformanceReport {
           let fps = getCurrentFPS()
           let frameTimeAvg = frameData.isEmpty ? 0 : frameData.reduce(0, +) / Double(frameData.count)
           let frameTimeMax = frameData.max() ?? 0
           let frameTimeMin = frameData.min() ?? 0
           
           return PerformanceReport(
               averageFPS: fps,
               averageFrameTime: frameTimeAvg * 1000, // ms로 변환
               maxFrameTime: frameTimeMax * 1000,
               minFrameTime: frameTimeMin * 1000
           )
       }
   }
   
   public struct PerformanceReport {
       public let averageFPS: Double
       public let averageFrameTime: Double // ms
       public let maxFrameTime: Double // ms
       public let minFrameTime: Double // ms
   }
   ```

2. **화면별 성능 테스트 실행**
   ```swift
   // App/Tests/PerformanceTests/UIPerformanceTests.swift
   import XCTest
   import AnalyticsModule
   
   final class UIPerformanceTests: XCTestCase {
       var app: XCUIApplication!
       
       override func setUp() {
           super.setUp()
           app = XCUIApplication()
           app.launchArguments = ["--enable-performance-monitoring"]
           app.launch()
           
           // 로그인
           loginForTesting()
       }
       
       func testAccountListPerformance() {
           // 계좌 목록 화면으로 이동
           app.tabBars.buttons["계좌"].tap()
           
           // 스크롤 성능 측정
           measure {
               let table = app.tables.firstMatch
               let start = table.cells.element(boundBy: 0)
               let end = table.cells.element(boundBy: table.cells.count - 1)
               
               start.swipeUp(repeatCount: 5)
               end.swipeDown(repeatCount: 5)
           }
           
           // 성능 데이터 수집
           let performanceData = getPerformanceData()
           XCTAssertGreaterThan(performanceData.averageFPS, 45, "FPS가 너무 낮습니다")
       }
       
       func testTransactionListPerformance() {
           // 계좌 상세 화면으로 이동
           app.tabBars.buttons["계좌"].tap()
           app.tables.cells.element(boundBy: 0).tap()
           
           // 스크롤 성능 측정
           measure {
               let table = app.tables["transactionListTable"]
               let start = table.cells.element(boundBy: 0)
               let end = table.cells.element(boundBy: table.cells.count - 1)
               
               start.swipeUp(repeatCount: 10)
               end.swipeDown(repeatCount: 10)
           }
           
           // 성능 데이터 수집
           let performanceData = getPerformanceData()
           XCTAssertGreaterThan(performanceData.averageFPS, 45, "FPS가 너무 낮습니다")
       }
       
       private func loginForTesting() {
           // 로그인 로직...
       }
       
       private func getPerformanceData() -> PerformanceReport {
           // 원격으로 성능 데이터 가져오기
           let performanceJSON = app.staticTexts["performanceData"].label
           let data = performanceJSON.data(using: .utf8)!
           return try! JSONDecoder().decode(PerformanceReport.self, from: data)
       }
   }
   ```

3. **렌더링 최적화 적용**
   ```swift
   // DesignSystem/Sources/Components/TableCells/OptimizedTransactionCell.swift
   import UIKit
   
   public final class OptimizedTransactionCell: UITableViewCell {
       // 성능 최적화된 셀 구현
       private let containerView = UIView()
       private let amountLabel = UILabel()
       private let descriptionLabel = UILabel()
       private let dateLabel = UILabel()
       
       // 이미지 캐싱
       private static let imageCache = NSCache<NSString, UIImage>()
       
       // 레이아웃 재계산 최소화
       private var appliedConstraints = false
       
       public override func prepareForReuse() {
           super.prepareForReuse()
           // 필요한 속성만 초기화
           amountLabel.text = nil
           descriptionLabel.text = nil
           dateLabel.text = nil
       }
       
       // 셀 내용 설정 시 효율적인 업데이트
       public func configure(with transaction: TransactionViewModel) {
           // 레이아웃이 적용되지 않았으면 한 번만 설정
           if !appliedConstraints {
               setupConstraints()
           }
           
           // 텍스트 업데이트
           amountLabel.text = transaction.formattedAmount
           descriptionLabel.text = transaction.description
           dateLabel.text = transaction.formattedDate
           
           // 텍스트 속성 업데이트 최적화
           if transaction.isOutgoing {
               amountLabel.textColor = .systemRed
           } else {
               amountLabel.textColor = .systemBlue
           }
           
           // 셀 배경 최적화 - drawRect 대신 설정
           backgroundColor = .clear
           contentView.backgroundColor = .clear
           containerView.backgroundColor = .systemBackground
       }
       
       private func setupConstraints() {
           // 레이아웃 설정...
           appliedConstraints = true
       }
   }
   ```

#### 3일차: 코드 품질 검증
1. **정적 분석 도구 실행**
   ```bash
   # SwiftLint 실행
   swiftlint --strict --reporter json > swiftlint-report.json
   
   # SonarQube 분석 실행
   sonar-scanner \
     -Dsonar.projectKey=TossBankClone \
     -Dsonar.sources=. \
     -Dsonar.exclusions=App/Derived/**,Tuist/**,**/*.generated.swift \
     -Dsonar.swift.swiftlint.reportPaths=swiftlint-report.json
   ```

2. **코드 품질 리포트 생성**
   ```markdown
   # 코드 품질 리포트
   
   ## 요약
   - **전체 소스 코드 파일**: 157개
   - **코드 라인 수**: 12,345줄
   - **테스트 커버리지**: 82.3%
   - **Critical Issues**: 0개
   - **Major Issues**: 5개
   - **Minor Issues**: 23개
   
   ## 모듈별 품질 지표
   | 모듈 | 파일 수 | 라인 수 | 테스트 커버리지 | 품질 등급 |
   |------|--------|--------|--------------|---------|
   | DomainModule | 32 | 2,145 | 92.1% | A |
   | DataModule | 25 | 1,876 | 87.3% | A |
   | NetworkModule | 18 | 1,523 | 85.2% | A |
   | ...etc | ... | ... | ... | ... |
   
   ## 주요 이슈 및 해결 방안
   1. **순환 복잡도 과다**: AccountViewModel의 perform 메서드(21)
      - 해결: 작은 헬퍼 메서드로 분리
   2. **메모리 누수 가능성**: TransferCoordinator의 클로저에서 self 강한 참조
      - 해결: [weak self] 사용
   3. **중복 코드**: APIRequest 구현체들에서 유사한 코드 반복
      - 해결: 템플릿 메서드 패턴 적용
   ```

3. **코드 리뷰 프로세스 문서화**
   ```markdown
   # 코드 리뷰 가이드라인
   
   ## 리뷰 체크리스트
   1. **아키텍처 준수**
      - 모듈 간 의존성 방향이 올바른가?
      - 계층 간 책임 분리가 명확한가?
   
   2. **코드 품질**
      - 메서드/클래스 복잡도가 적절한가?
      - 네이밍이 명확하고 일관적인가?
      - 주석이 필요한 곳에 적절히 작성되었는가?
   
   3. **테스트**
      - 단위 테스트가 작성되었는가?
      - 테스트 커버리지가 충분한가?
      - 엣지 케이스를 고려했는가?
   
   4. **성능**
      - 불필요한 연산이나 메모리 사용이 있는가?
      - 대용량 데이터 처리가 효율적인가?
   
   ## 리뷰 프로세스
   1. PR 템플릿 작성
   2. 최소 2명의 리뷰어 지정
   3. CI 파이프라인 통과 확인
   4. 코드 리뷰 수행 (최대 48시간 내)
   5. 리뷰 피드백 반영
   6. 최종 승인 및 머지
   ```

### 6-2: 아키텍처 문서 갱신 (4일)

#### 4-5일차: 실제 구현된 아키텍처 문서화
1. **최종 아키텍처 문서 작성**
   ```markdown
   # 토스뱅크 클론 앱 아키텍처 문서
   
   ## 개요
   이 문서는 토스뱅크 클론 앱의 최종 구현된 아키텍처에 대해 설명합니다. 앱은 Clean Architecture와 모듈화 원칙을 기반으로 개발되었으며, 다음과 같은 주요 모듈로 구성됩니다.
   
   ## 모듈 구조
   
   ### 계층별 모듈
   1. **앱 모듈(App)**: 앱의 진입점 및 모듈 조합
   2. **기능 모듈(Features)**: Account, Auth, Transfer, Settings
   3. **코어 모듈(Core)**: Domain, Data, Network, Database, Authentication
   4. **플랫폼 모듈(Platform)**: DesignSystem, Utils, Analytics, Testing
   
   ### 의존성 흐름
   ```mermaid
   flowchart TD
       App --> Features
       App --> Core
       App --> Platform
       Features --> Core
       Features --> Platform
       Core --> Platform
   ```
   
   ## 모듈 간 통신
   1. **직접 의존성**: 상위 모듈에서 하위 모듈로의 직접 참조 (예: Features → Domain)
   2. **프로토콜 통신**: 의존성 역전을 통한 통신 (예: Data → Domain)
   3. **이벤트 기반 통신**: EventBus를 통한 모듈 간 간접 통신
   
   ## 핵심 패턴
   1. **Clean Architecture**: 비즈니스 로직을 격리하고 계층 간 명확한 경계 설정
   2. **MVVM**: 프레젠테이션 계층의 상태 관리 및 비즈니스 로직 분리
   3. **Coordinator**: 화면 전환 및 네비게이션 흐름 관리
   4. **Repository**: 데이터 액세스 추상화
   5. **DIContainer**: 의존성 주입 및 객체 생성 관리
   
   ## 성능 최적화
   1. **렌더링 최적화**: 효율적인 UI 컴포넌트 및 데이터 바인딩
   2. **메모리 관리**: 적절한 객체 라이프사이클 관리 및 누수 방지
   3. **비동기 처리**: Swift Concurrency를 활용한 효율적인 비동기 작업 처리
   
   ## 테스트 전략
   1. **단위 테스트**: 비즈니스 로직 및 유스케이스 검증
   2. **통합 테스트**: 모듈 간 연동 검증
   3. **UI 테스트**: 사용자 흐름 및 인터페이스 검증
   ```

2. **최종 모듈 의존성 그래프 생성**
   ```bash
   # 의존성 그래프 생성 및 문서화
   tuist graph --skip-external-dependencies
   ```

3. **리팩터링 결과 문서**
   ```markdown
   # 리팩터링 결과 보고서
   
   ## 목표 달성 여부
   
   ### 목표 1: 모듈 구조 개선
   - ✅ Database 모듈 분리
   - ✅ Utils, Analytics, Testing 모듈 추가
   - ✅ 모듈 간 의존성 방향 최적화
   
   ### 목표 2: 코드 품질 향상
   - ✅ 테스트 커버리지 80% 이상 달성
   - ✅ 정적 분석 도구를 통한 코드 품질 개선
   - ✅ 성능 최적화 적용
   
   ### 목표 3: 아키텍처 표준화
   - ✅ Clean Architecture 원칙 적용
   - ✅ 의존성 주입 시스템 표준화
   - ✅ Coordinator 패턴 개선
   
   ## 변경 내역 요약
   1. **모듈 구조 변경**
      - 5개 코어 모듈 (Domain, Data, Network, Database, Authentication)
      - 4개 기능 모듈 (Account, Auth, Transfer, Settings)
      - 4개 플랫폼 모듈 (DesignSystem, Utils, Analytics, Testing)
   
   2. **인터페이스 개선**
      - 표준화된 Repository 패턴
      - 일관된 오류 처리 메커니즘
      - 통합된 이벤트 처리 시스템
   
   3. **테스트 인프라 강화**
      - 자동화된 테스트 파이프라인
      - 모듈별 테스트 커버리지 측정
      - UI 및 성능 테스트 도구
   
   ## 향후 개선 사항
   1. 테스트 커버리지 추가 개선 (목표: 90%)
   2. CI/CD 파이프라인 고도화
   3. 성능 모니터링 시스템 확장
   ```

#### 6-7일차: 모듈별 README 업데이트 및 아키텍처 다이어그램 갱신
1. **모듈별 README 템플릿 정의**
   ```markdown
   # 모듈명
   
   ## 개요
   모듈에 대한 간략한 설명과 역할
   
   ## 아키텍처
   모듈 내부 구조에 대한 설명과 다이어그램
   
   ## 주요 컴포넌트
   - Component1: 설명
   - Component2: 설명
   
   ## 사용 방법
   코드 예시와 함께 모듈 사용 방법 설명
   
   ## 테스트
   테스트 전략 및 실행 방법
   
   ## 의존성
   모듈의 외부 의존성 목록
   ```

2. **아키텍처 다이어그램 갱신**
   ```mermaid
   flowchart TD
       subgraph App["App Module"]
           AppDelegate
           SceneDelegate
           AppCoordinator
           AppDIContainer
       end
       
       subgraph Features["Feature Modules"]
           Account["Account Module"]
           Auth["Auth Module"]
           Transfer["Transfer Module"]
           Settings["Settings Module"]
       end
       
       subgraph Core["Core Modules"]
           Domain["Domain Module"]
           Data["Data Module"]
           Network["Network Module"]
           Database["Database Module"]
           Authentication["Authentication Module"]
       end
       
       subgraph Platform["Platform Modules"]
           DesignSystem["DesignSystem Module"]
           Utils["Utils Module"]
           Analytics["Analytics Module"]
           Testing["Testing Module"]
       end
       
       App --> Features
       App --> Core
       App --> Platform
       
       Features --> Core
       Features --> Platform
       
       Auth --> Authentication
       Account --> Domain
       Transfer --> Domain
       Settings --> Domain
       
       Domain --> Data
       Data --> Network
       Data --> Database
       
       Authentication --> Network
       Authentication --> Database
       
       Domain --> Platform
       Data --> Platform
       Network --> Platform
       Database --> Platform
       Authentication --> Platform
   ```

3. **개발자 가이드 작성**
   ```markdown
   # 개발자 가이드
   
   ## 개발 환경 설정
   1. **프로젝트 클론**
      ```bash
      git clone https://github.com/username/TossBankClone.git
      cd TossBankClone
      ```
   
   2. **의존성 설치**
      ```bash
      brew install tuist
      ```
   
   3. **프로젝트 생성**
      ```bash
      tuist generate
      ```
   
   4. **Xcode 실행**
      ```bash
      open TossBankClone.xcworkspace
      ```
   
   ## 코딩 가이드라인
   1. **아키텍처 준수**
      - Clean Architecture 계층 분리 유지
      - 모듈 간 의존성 방향 준수
   
   2. **코딩 컨벤션**
      - Swift Style Guide 준수
      - 네이밍 규칙 및 코드 구조화 방법
   
   3. **테스트 작성**
      - 기능 개발 시 단위 테스트 필수 작성
      - TDD 접근법 권장
   
   ## 워크플로우
   1. **브랜치 관리**
      - `main`: 제품 릴리스
      - `develop`: 개발 통합
      - `feature/*`: 기능 개발
      - `bugfix/*`: 버그 수정
   
   2. **커밋 메시지**
      - `feat:` 새로운 기능
      - `fix:` 버그 수정
      - `refactor:` 코드 리팩토링
      - `docs:` 문서화
      - `test:` 테스트 추가/수정
   
   3. **PR 및 리뷰**
      - PR 템플릿 사용
      - 코드 리뷰 체크리스트 확인
   
   ## 모듈 구조
   [모듈 구조 설명 및 다이어그램]
   
   ## 새 기능 추가 방법
   [새 기능 추가 단계별 가이드]
   ```

## 6단계 산출물 체크리스트

- [ ] 메모리 누수 검사 및 수정 완료
- [ ] UI 렌더링 성능 측정 및 최적화 완료
- [ ] 코드 품질 검증 및 리포트 생성 완료
- [ ] 최종 아키텍처 문서 작성 완료
- [ ] 모듈별 README 업데이트 완료
- [ ] 아키텍처 다이어그램 갱신 완료
- [ ] 개발자 가이드 작성 완료
- [ ] 리팩터링 결과 보고서 작성 완료

이 6단계 실행 계획을 통해 리팩터링 과정의 성과를 검증하고, 결과물을 문서화하여 향후 개발 팀원들이 프로젝트 구조를 이해하고 효율적으로 작업할 수 있는 기반을 마련할 수 있습니다. 또한 최종 리팩터링 결과물의 품질을 검증함으로써 프로젝트의 안정성과 유지보수성을 확보할 수 있습니다.
