
# 토스뱅크 클론 프로젝트 리팩터링 3단계 실행 계획

## 3단계: 코어 모듈 재구성 (3주)

### 3-1: Database 모듈 분리 (1주)

#### 1-2일차: DataModule 분석 및 분리 계획 수립
1. **현재 데이터 저장 구조 분석**
   ```bash
   # DataModule 내 로컬 저장소 관련 코드 식별
   find App/Modules/DataModule -type f -name "*.swift" | xargs grep -l "SwiftData\|CoreData\|UserDefaults\|Keychain"
   ```

2. **의존성 그래프 분석**
   - DataModule과 다른 모듈 간의 의존성 식별
   - 로컬 데이터 저장소에 의존하는 코드 경로 확인

3. **분리 계획 수립**
   - 분리할 코드 목록 작성
   - 마이그레이션 순서 결정
   - 영향 받는 모듈 식별

#### 3-4일차: SwiftData/CoreData 관련 코드 분리
1. **DatabaseModule 스켈레톤 생성**
   ```swift
   // DatabaseModule/Project.swift 생성
   import ProjectDescription
   
   let project = Project(
       name: "DatabaseModule",
       organizationName: "TossBankClone",
       options: .options(
           automaticSchemesOptions: .disabled
       ),
       packages: [],
       settings: .settings(
           base: [:],
           configurations: [
               .debug(name: "Debug"),
               .release(name: "Release")
           ],
           defaultSettings: .recommended
       ),
       targets: [
           Target(
               name: "DatabaseModule",
               platform: .iOS,
               product: .framework,
               bundleId: "com.tossbankclone.databasemodule",
               deploymentTarget: .iOS(targetVersion: "15.0", devices: [.iphone]),
               infoPlist: .default,
               sources: ["Sources/**"],
               resources: ["Resources/**"],
               dependencies: []
           ),
           Target(
               name: "DatabaseModuleTests",
               platform: .iOS,
               product: .unitTests,
               bundleId: "com.tossbankclone.databasemodule.tests",
               deploymentTarget: .iOS(targetVersion: "15.0", devices: [.iphone]),
               infoPlist: .default,
               sources: ["Tests/**"],
               dependencies: [
                   .target(name: "DatabaseModule")
               ]
           )
       ]
   )
   ```

2. **코어 데이터 관리 클래스 이전**
   - CoreDataManager, SwiftDataManager 등 핵심 클래스 이전
   - 스키마 정의 및 마이그레이션 코드 이전

3. **데이터 액세스 레이어 구현**
   ```swift
   // DatabaseModule/Sources/Core/DatabaseManager.swift
   import Foundation
   import SwiftData
   
   public protocol DatabaseManagerProtocol {
       func save<T: PersistentModel>(_ item: T) async throws
       func fetch<T: PersistentModel>(_ type: T.Type, predicate: Predicate<T>?) async throws -> [T]
       func delete<T: PersistentModel>(_ item: T) async throws
   }
   
   public final class DatabaseManager: DatabaseManagerProtocol {
       private let modelContainer: ModelContainer
       private let modelContext: ModelContext
       
       public init() throws {
           let schema = Schema([
               // 모델 스키마 정의
           ])
           self.modelContainer = try ModelContainer(for: schema)
           self.modelContext = ModelContext(modelContainer)
       }
       
       public func save<T: PersistentModel>(_ item: T) async throws {
           modelContext.insert(item)
           try modelContext.save()
       }
       
       public func fetch<T: PersistentModel>(_ type: T.Type, predicate: Predicate<T>? = nil) async throws -> [T] {
           let descriptor = FetchDescriptor<T>(predicate: predicate)
           return try modelContext.fetch(descriptor)
       }
       
       public func delete<T: PersistentModel>(_ item: T) async throws {
           modelContext.delete(item)
           try modelContext.save()
       }
   }
   ```

#### 5-6일차: Repository 패턴 인터페이스 유지하며 구현 분리
1. **데이터 액세스 계층 정의**
   ```swift
   // DatabaseModule/Sources/DataSources/LocalDataSource.swift
   import Foundation
   
   public protocol LocalDataSource {
       func save<T: Codable>(_ item: T, forKey key: String) throws
       func retrieve<T: Codable>(_ type: T.Type, forKey key: String) throws -> T?
       func remove(forKey key: String) throws
   }
   
   public final class DefaultLocalDataSource: LocalDataSource {
       private let databaseManager: DatabaseManagerProtocol
       
       public init(databaseManager: DatabaseManagerProtocol) {
           self.databaseManager = databaseManager
       }
       
       // 구현...
   }
   ```

2. **DataModule의 로컬 저장소 의존성 수정**
   ```swift
   // DataModule/Sources/Repositories/AccountRepository.swift
   import Foundation
   import DomainModule
   import DatabaseModule
   
   public final class AccountRepositoryImpl: AccountRepository {
       private let remoteDataSource: AccountRemoteDataSource
       private let localDataSource: LocalDataSource // DatabaseModule에서 가져옴
       
       public init(remoteDataSource: AccountRemoteDataSource, localDataSource: LocalDataSource) {
           self.remoteDataSource = remoteDataSource
           self.localDataSource = localDataSource
       }
       
       // 구현...
   }
   ```

3. **DI 컨테이너 업데이트**
   ```swift
   // DataModule/Sources/DIContainer/DataDIContainer.swift
   import Foundation
   import NetworkModule
   import DatabaseModule
   
   public final class DataDIContainer {
       private let networkContainer: NetworkDIContainer
       private let databaseManager: DatabaseManagerProtocol
       
       public init(networkContainer: NetworkDIContainer, databaseManager: DatabaseManagerProtocol) {
           self.networkContainer = networkContainer
           self.databaseManager = databaseManager
       }
       
       // 의존성 제공 메서드...
   }
   ```

#### 7일차: 단위 테스트로 기능 검증
1. **데이터베이스 모듈 테스트 작성**
   ```swift
   // DatabaseModuleTests/DatabaseManagerTests.swift
   import XCTest
   @testable import DatabaseModule
   
   final class DatabaseManagerTests: XCTestCase {
       var sut: DatabaseManager!
       
       override func setUp() {
           super.setUp()
           // 인메모리 데이터베이스 설정
           sut = try! DatabaseManager(inMemory: true)
       }
       
       override func tearDown() {
           sut = nil
           super.tearDown()
       }
       
       func test_SaveAndFetch() async throws {
           // 테스트 구현
       }
       
       // 추가 테스트...
   }
   ```

2. **기존 Repository 테스트 수정**
   - 데이터베이스 모듈 의존성 추가로 인한 테스트 수정
   - 모의 객체 생성 로직 업데이트

3. **통합 테스트 실행**
   ```bash
   tuist test DatabaseModule
   tuist test DataModule
   ```

### 3-2: NetworkModule 최적화 (1주)

#### 8-9일차: 네트워크 계층 추상화 개선
1. **NetworkClient 인터페이스 정리**
   ```swift
   // NetworkModule/Sources/Core/NetworkClient.swift
   import Foundation
   
   public protocol NetworkClient {
       func request<T: Decodable>(_ endpoint: Endpoint) async throws -> T
       func upload<T: Decodable>(data: Data, to endpoint: Endpoint) async throws -> T
       func download(from endpoint: Endpoint) async throws -> URL
   }
   
   public final class DefaultNetworkClient: NetworkClient {
       private let session: URLSession
       private let plugins: [NetworkPlugin]
       
       public init(session: URLSession = .shared, plugins: [NetworkPlugin] = []) {
           self.session = session
           self.plugins = plugins
       }
       
       // 구현...
   }
   ```

2. **Endpoint 구조 표준화**
   ```swift
   // NetworkModule/Sources/Core/Endpoint.swift
   import Foundation
   
   public struct Endpoint {
       public let baseURL: URL
       public let path: String
       public let method: HTTPMethod
       public let task: HTTPTask
       public let headers: [String: String]?
       
       public init(baseURL: URL, 
                  path: String, 
                  method: HTTPMethod, 
                  task: HTTPTask = .requestPlain, 
                  headers: [String: String]? = nil) {
           self.baseURL = baseURL
           self.path = path
           self.method = method
           self.task = task
           self.headers = headers
       }
       
       public func urlRequest() -> URLRequest {
           // URLRequest 생성 로직
       }
   }
   ```

3. **모듈 공개 API 정리**
   - 내부용/공개용 타입 분리
   - 네트워크 모듈 공개 인터페이스 최소화

#### 10-12일차: 에러 처리 메커니즘 표준화
1. **네트워크 에러 정의 개선**
   ```swift
   // NetworkModule/Sources/Errors/NetworkError.swift
   import Foundation
   
   public enum NetworkError: Error {
       case invalidRequest
       case invalidResponse
       case httpError(statusCode: Int, data: Data?)
       case decodingError(Error)
       case connectionError(Error)
       case serverError(message: String)
       case unauthorized
       case unknown
       
       public var isRetryable: Bool {
           switch self {
           case .connectionError, .serverError:
               return true
           case .httpError(let statusCode, _):
               return statusCode >= 500
           default:
               return false
           }
       }
   }
   
   extension NetworkError: LocalizedError {
       public var errorDescription: String? {
           switch self {
           case .invalidRequest:
               return "유효하지 않은 요청입니다."
           // 추가 케이스...
           }
       }
   }
   ```

2. **에러 인터셉터 구현**
   ```swift
   // NetworkModule/Sources/Plugins/ErrorInterceptorPlugin.swift
   import Foundation
   
   public final class ErrorInterceptorPlugin: NetworkPlugin {
       public init() {}
       
       public func prepare(_ request: URLRequest) -> URLRequest {
           return request
       }
       
       public func process(_ result: Result<(Data, URLResponse), Error>, for request: URLRequest) -> Result<(Data, URLResponse), Error> {
           switch result {
           case .success(let response):
               let (data, urlResponse) = response
               guard let httpResponse = urlResponse as? HTTPURLResponse else {
                   return .failure(NetworkError.invalidResponse)
               }
               
               switch httpResponse.statusCode {
               case 200...299:
                   return .success(response)
               case 401:
                   return .failure(NetworkError.unauthorized)
               case 400...499:
                   return .failure(NetworkError.httpError(statusCode: httpResponse.statusCode, data: data))
               case 500...599:
                   return .failure(NetworkError.serverError(message: String(data: data, encoding: .utf8) ?? "서버 오류"))
               default:
                   return .failure(NetworkError.unknown)
               }
           case .failure(let error):
               if let urlError = error as? URLError {
                   return .failure(NetworkError.connectionError(urlError))
               }
               return .failure(error)
           }
       }
   }
   ```

3. **에러 핸들링 가이드 작성**
   ```markdown
   # 네트워크 에러 핸들링 가이드
   
   ## 개요
   이 문서는 네트워크 에러를 효과적으로 처리하는 표준 방식을 설명합니다.
   
   ## 에러 타입
   - `NetworkError` - 네트워크 계층의 모든 에러를 표현
   - `DomainError` - 비즈니스 로직 관점에서의 에러 표현
   
   ## 에러 변환 과정
   1. 네트워크 요청 실패 → NetworkError 생성
   2. Repository에서 NetworkError → DomainError 변환
   3. UseCase에서 적절한 에러 처리 및 전파
   4. ViewModel에서 사용자에게 표시할 에러 메시지 결정
   
   ## 코드 예시
   ```swift
   // 코드 예시
   ```
   ```

#### 13-14일차: 플러그인 시스템 강화
1. **플러그인 인터페이스 개선**
   ```swift
   // NetworkModule/Sources/Plugins/NetworkPlugin.swift
   import Foundation
   
   public protocol NetworkPlugin {
       func prepare(_ request: URLRequest) -> URLRequest
       func process(_ result: Result<(Data, URLResponse), Error>, for request: URLRequest) -> Result<(Data, URLResponse), Error>
       func willSend(_ request: URLRequest)
       func didReceive(_ result: Result<(Data, URLResponse), Error>, for request: URLRequest)
   }
   
   // 기본 구현으로 선택적 오버라이드 지원
   public extension NetworkPlugin {
       func willSend(_ request: URLRequest) {}
       func didReceive(_ result: Result<(Data, URLResponse), Error>, for request: URLRequest) {}
   }
   ```

2. **표준 플러그인 구현**
   ```swift
   // NetworkModule/Sources/Plugins/LoggingPlugin.swift
   import Foundation
   import OSLog
   
   public final class LoggingPlugin: NetworkPlugin {
       private let logger = Logger(subsystem: "com.tossbankclone", category: "Network")
       
       public init() {}
       
       public func prepare(_ request: URLRequest) -> URLRequest {
           return request
       }
       
       public func willSend(_ request: URLRequest) {
           logger.debug("🚀 REQUEST: \(request.url?.absoluteString ?? "unknown")")
           if let headers = request.allHTTPHeaderFields, !headers.isEmpty {
               logger.debug("📋 HEADERS: \(headers)")
           }
           if let body = request.httpBody, let bodyString = String(data: body, encoding: .utf8) {
               logger.debug("📦 BODY: \(bodyString)")
           }
       }
       
       public func process(_ result: Result<(Data, URLResponse), Error>, for request: URLRequest) -> Result<(Data, URLResponse), Error> {
           return result
       }
       
       public func didReceive(_ result: Result<(Data, URLResponse), Error>, for request: URLRequest) {
           switch result {
           case .success(let response):
               let (data, urlResponse) = response
               if let httpResponse = urlResponse as? HTTPURLResponse {
                   logger.debug("✅ RESPONSE: \(httpResponse.statusCode) - \(request.url?.absoluteString ?? "unknown")")
               }
               if let responseString = String(data: data, encoding: .utf8) {
                   logger.debug("📄 DATA: \(responseString)")
               }
           case .failure(let error):
               logger.error("❌ ERROR: \(error.localizedDescription) - \(request.url?.absoluteString ?? "unknown")")
           }
       }
   }
   ```

3. **플러그인 활용 최적화**
   ```swift
   // NetworkModule/Sources/DIContainer/NetworkDIContainer.swift
   import Foundation
   
   public final class NetworkDIContainer {
       public func makeNetworkClient() -> NetworkClient {
           let plugins: [NetworkPlugin] = [
               AuthorizationPlugin(tokenProvider: makeTokenProvider()),
               ErrorInterceptorPlugin(),
               LoggingPlugin(),
               NetworkActivityPlugin(),
               // 추가 플러그인...
           ]
           
           return DefaultNetworkClient(plugins: plugins)
       }
       
       // 추가 메서드...
   }
   ```

### 3-3: DomainModule 및 AuthenticationModule 정리 (1주)

#### 15-16일차: 엔티티 모델 최적화
1. **도메인 엔티티 재정의**
   ```swift
   // DomainModule/Sources/Entities/Account.swift
   import Foundation
   
   public struct Account: Equatable, Identifiable {
       public let id: String
       public let name: String
       public let type: AccountType
       public let balance: Decimal
       public let currency: Currency
       public let isActive: Bool
       public let createdAt: Date
       
       public init(id: String, name: String, type: AccountType, balance: Decimal, currency: Currency, isActive: Bool, createdAt: Date) {
           self.id = id
           self.name = name
           self.type = type
           self.balance = balance
           self.currency = currency
           self.isActive = isActive
           self.createdAt = createdAt
       }
   }
   
   public enum AccountType: String, Codable, CaseIterable {
       case checking
       case savings
       case investment
       
       public var displayName: String {
           switch self {
           case .checking: return "입출금"
           case .savings: return "적금"
           case .investment: return "투자"
           }
       }
   }
   
   public enum Currency: String, Codable {
       case krw = "KRW"
       case usd = "USD"
       case eur = "EUR"
       case jpy = "JPY"
       
       public var symbol: String {
           switch self {
           case .krw: return "₩"
           case .usd: return "$"
           case .eur: return "€"
           case .jpy: return "¥"
           }
       }
   }
   ```

2. **값 객체(Value Object) 도입**
   ```swift
   // DomainModule/Sources/Entities/Money.swift
   import Foundation
   
   public struct Money: Equatable, Codable {
       public let amount: Decimal
       public let currency: Currency
       
       public init(amount: Decimal, currency: Currency) {
           self.amount = amount
           self.currency = currency
       }
       
       public func formatted() -> String {
           let formatter = NumberFormatter()
           formatter.numberStyle = .currency
           formatter.currencySymbol = currency.symbol
           formatter.minimumFractionDigits = 0
           formatter.maximumFractionDigits = 2
           
           return formatter.string(from: amount as NSDecimalNumber) ?? "\(currency.symbol)\(amount)"
       }
       
       // 돈 연산 메서드 추가 (덧셈, 뺄셈 등)
   }
   ```

3. **도메인 오류 정의**
   ```swift
   // DomainModule/Sources/Entities/DomainError.swift
   import Foundation
   
   public enum DomainError: Error {
       case invalidInput
       case entityNotFound
       case permissionDenied
       case insufficientFunds
       case serviceUnavailable
       case networkError(message: String)
       case authenticationRequired
       case validationFailed(field: String, message: String)
       case unknown
   }
   
   extension DomainError: LocalizedError {
       public var errorDescription: String? {
           switch self {
           case .invalidInput:
               return "유효하지 않은 입력입니다."
           case .entityNotFound:
               return "요청한 정보를 찾을 수 없습니다."
           case .permissionDenied:
               return "권한이 없습니다."
           case .insufficientFunds:
               return "잔액이 부족합니다."
           case .serviceUnavailable:
               return "서비스를 이용할 수 없습니다. 잠시 후 다시 시도해주세요."
           case .networkError(let message):
               return "네트워크 오류: \(message)"
           case .authenticationRequired:
               return "로그인이 필요합니다."
           case .validationFailed(let field, let message):
               return "\(field): \(message)"
           case .unknown:
               return "알 수 없는 오류가 발생했습니다."
           }
       }
   }
   ```

#### 17-18일차: 유스케이스 구조 개선
1. **기본 유스케이스 프로토콜 정의**
   ```swift
   // DomainModule/Sources/UseCases/UseCase.swift
   import Foundation
   
   public protocol UseCase {
       associatedtype Input
       associatedtype Output
       
       func execute(input: Input) async throws -> Output
   }
   
   public protocol NoInputUseCase {
       associatedtype Output
       
       func execute() async throws -> Output
   }
   
   public protocol NoOutputUseCase {
       associatedtype Input
       
       func execute(input: Input) async throws
   }
   
   public protocol SimpleUseCase {
       func execute() async throws
   }
   ```

2. **유스케이스 구현 표준화**
   ```swift
   // DomainModule/Sources/UseCases/Account/GetAccountsUseCase.swift
   import Foundation
   
   public final class GetAccountsUseCase: NoInputUseCase {
       public typealias Output = [Account]
       
       private let accountRepository: AccountRepository
       
       public init(accountRepository: AccountRepository) {
           self.accountRepository = accountRepository
       }
       
       public func execute() async throws -> [Account] {
           return try await accountRepository.getAccounts()
       }
   }
   
   // DomainModule/Sources/UseCases/Transfer/TransferMoneyUseCase.swift
   public struct TransferMoneyInput {
       public let sourceAccountId: String
       public let destinationAccountId: String
       public let amount: Money
       public let description: String?
       
       public init(sourceAccountId: String, destinationAccountId: String, amount: Money, description: String? = nil) {
           self.sourceAccountId = sourceAccountId
           self.destinationAccountId = destinationAccountId
           self.amount = amount
           self.description = description
       }
   }
   
   public final class TransferMoneyUseCase: UseCase {
       public typealias Input = TransferMoneyInput
       public typealias Output = TransferResult
       
       private let accountRepository: AccountRepository
       private let transferRepository: TransferRepository
       
       public init(accountRepository: AccountRepository, transferRepository: TransferRepository) {
           self.accountRepository = accountRepository
           self.transferRepository = transferRepository
       }
       
       public func execute(input: TransferMoneyInput) async throws -> TransferResult {
           // 구현...
       }
   }
   ```

3. **DIContainer 업데이트**
   ```swift
   // DomainModule/Sources/DIContainer/DomainDIContainer.swift
   import Foundation
   
   public final class DomainDIContainer {
       private let repositories: RepositoryProvider
       
       public init(repositories: RepositoryProvider) {
           self.repositories = repositories
       }
       
       // 계좌 관련 유스케이스
       public func makeGetAccountsUseCase() -> GetAccountsUseCase {
           return GetAccountsUseCase(accountRepository: repositories.makeAccountRepository())
       }
       
       public func makeGetAccountDetailUseCase() -> GetAccountDetailUseCase {
           return GetAccountDetailUseCase(accountRepository: repositories.makeAccountRepository())
       }
       
       // 이체 관련 유스케이스
       public func makeTransferMoneyUseCase() -> TransferMoneyUseCase {
           return TransferMoneyUseCase(
               accountRepository: repositories.makeAccountRepository(),
               transferRepository: repositories.makeTransferRepository()
           )
       }
       
       // 추가 유스케이스 팩토리 메서드...
   }
   ```

#### 19-21일차: 인증 관련 책임 명확화
1. **AuthenticationModule 인터페이스 개선**
   ```swift
   // AuthenticationModule/Sources/Manager/AuthManager.swift
   import Foundation
   
   public protocol AuthManagerProtocol {
       var isAuthenticated: Bool { get }
       var currentUser: User? { get }
       
       func signIn(username: String, password: String) async throws -> User
       func signOut() async throws
       func refreshToken() async throws -> String
       func getAccessToken() async throws -> String
   }
   
   public final class AuthManager: AuthManagerProtocol {
       private let authRepository: AuthRepository
       private let tokenStorage: TokenStorage
       private let userSession: UserSession
       
       public init(authRepository: AuthRepository, tokenStorage: TokenStorage, userSession: UserSession) {
           self.authRepository = authRepository
           self.tokenStorage = tokenStorage
           self.userSession = userSession
       }
       
       public var isAuthenticated: Bool {
           return userSession.currentUser != nil && tokenStorage.hasValidToken
       }
       
       public var currentUser: User? {
           return userSession.currentUser
       }
       
       public func signIn(username: String, password: String) async throws -> User {
           let authResponse = try await authRepository.signIn(username: username, password: password)
           
           try tokenStorage.saveTokens(access: authResponse.accessToken, refresh: authResponse.refreshToken)
           let user = authResponse.user
           userSession.setCurrentUser(user)
           
           return user
       }
       
       public func signOut() async throws {
           try tokenStorage.clearTokens()
           userSession.clearCurrentUser()
           try? await authRepository.signOut()
       }
       
       public func refreshToken() async throws -> String {
           guard let refreshToken = tokenStorage.refreshToken else {
               throw AuthError.noRefreshToken
           }
           
           let tokens = try await authRepository.refreshToken(refreshToken: refreshToken)
           try tokenStorage.saveTokens(access: tokens.accessToken, refresh: tokens.refreshToken)
           
           return tokens.accessToken
       }
       
       public func getAccessToken() async throws -> String {
           if let token = tokenStorage.accessToken, !tokenStorage.isAccessTokenExpired {
               return token
           }
           
           return try await refreshToken()
       }
   }
   ```

2. **토큰 관리 최적화**
   ```swift
   // AuthenticationModule/Sources/Manager/TokenStorage.swift
   import Foundation
   import KeychainAccess
   
   public protocol TokenStorage {
       var accessToken: String? { get }
       var refreshToken: String? { get }
       var hasValidToken: Bool { get }
       var isAccessTokenExpired: Bool { get }
       
       func saveTokens(access: String, refresh: String) throws
       func clearTokens() throws
   }
   
   public final class KeychainTokenStorage: TokenStorage {
       private let keychain: Keychain
       private let accessTokenKey = "access_token"
       private let refreshTokenKey = "refresh_token"
       private let accessTokenExpiryKey = "access_token_expiry"
       
       public init() {
           self.keychain = Keychain(service: "com.tossbankclone.auth")
       }
       
       public var accessToken: String? {
           try? keychain.get(accessTokenKey)
       }
       
       public var refreshToken: String? {
           try? keychain.get(refreshTokenKey)
       }
       
       public var hasValidToken: Bool {
           return accessToken != nil && refreshToken != nil
       }
       
       public var isAccessTokenExpired: Bool {
           guard let expiryString = try? keychain.get(accessTokenExpiryKey),
                 let expiry = Double(expiryString) else {
               return true
           }
           
           return Date().timeIntervalSince1970 > expiry
       }
       
       public func saveTokens(access: String, refresh: String) throws {
           // 액세스 토큰 만료 시간 계산 (현재 시간 + 1시간)
           let expiry = Date().timeIntervalSince1970 + 3600
           
           try keychain
               .set(access, key: accessTokenKey)
               .set(refresh, key: refreshTokenKey)
               .set(String(expiry), key: accessTokenExpiryKey)
       }
       
       public func clearTokens() throws {
           try keychain
               .remove(accessTokenKey)
               .remove(refreshTokenKey)
               .remove(accessTokenExpiryKey)
       }
   }
   ```

3. **인증 처리 흐름 문서화**
   ```markdown
   # 인증 흐름 가이드
   
   ## 개요
   이 문서는 앱의 인증 처리 흐름을 설명합니다.
   
   ## 인증 상태 관리
   - `AuthManager`는 사용자의 인증 상태를 중앙에서 관리합니다.
   - `TokenStorage`는 인증 토큰을 안전하게 저장하고 관리합니다.
   - `UserSession`은 현재 로그인한 사용자 정보를 관리합니다.
   
   ## 인증 흐름
   1. 로그인: 사용자 인증 정보로 API 호출 → 토큰 발급 → 토큰 저장 → 사용자 세션 생성
   2. API 요청: 액세스 토큰 확인 → 만료 시 갱신 → 요청에 토큰 첨부
   3. 로그아웃: 토큰 삭제 → 사용자 세션 제거 → 서버에 로그아웃 알림
   
   ## 토큰 갱신 전략
   - 액세스 토큰 만료 시 자동으로 리프레시 토큰을 사용하여 갱신
   - 리프레시 토큰도 만료된 경우 사용자에게 재로그인 요청
   
   ## 오류 처리
   - 인증 오류 발생 시 적절한 사용자 피드백 제공
   - 401 에러 발생 시 토큰 갱신 시도 후 재시도
   ```

## 3단계 산출물 체크리스트

- [ ] Database 모듈 생성 및 코드 이전 완료
- [ ] Repository 패턴 인터페이스 유지하며 구현 분리 완료
- [ ] DataModule과 DatabaseModule 간 의존성 설정 완료
- [ ] NetworkModule 추상화 계층 개선 완료
- [ ] 네트워크 에러 처리 메커니즘 표준화 완료
- [ ] 플러그인 시스템 강화 완료
- [ ] DomainModule 엔티티 및 유스케이스 최적화 완료
- [ ] AuthenticationModule 인터페이스 및 책임 명확화 완료
- [ ] 모든 변경사항에 대한 단위 테스트 작성 완료
- [ ] 3단계 완료 보고서 및 4단계 세부 계획

이 3단계 실행 계획을 통해 코어 모듈의 구조를 개선하고, 아키텍처 문서에 제시된 이상적인 구조에 가깝게 발전시킬 수 있습니다.
