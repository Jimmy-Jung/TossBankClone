
# 토스뱅크 클론 프로젝트 리팩터링 2단계 실행 계획

## 2단계: 핵심 아키텍처 구조 재정립 (2주)

### 2-1: App 모듈 역할 명확화 (1주)

#### 1-2일차: 앱 진입점 역할 강화
1. **AppDelegate 및 SceneDelegate 최적화**
   ```swift
   // AppDelegate.swift 개선
   import UIKit
   import SharedModule
   
   @main
   class AppDelegate: UIResponder, UIApplicationDelegate {
       var appDIContainer: AppDIContainer!
       var appCoordinator: AppCoordinator!
       
       func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
           // 앱 수준 서비스 초기화를 명확하게 분리
           setupDependencies()
           setupAppearance()
           setupCoordinator()
           return true
       }
       
       private func setupDependencies() {
           appDIContainer = AppDIContainer()
       }
       
       private func setupAppearance() {
           // 앱 전체 UI 스타일 설정
       }
       
       private func setupCoordinator() {
           appCoordinator = AppCoordinator(window: window, diContainer: appDIContainer)
           appCoordinator.start()
       }
   }
   ```

2. **앱 시작 흐름 최적화**
   - 스플래시 화면 → 로그인/메인 화면 전환 로직 개선
   - 딥링크 핸들러 구현/개선

3. **앱 상태 관리 정리**
   - 포그라운드/백그라운드 전환 처리 통합
   - 메모리 경고 처리 개선

#### 3-5일차: 의존성 주입 설정 최적화
1. **App DIContainer 구조화**
   ```swift
   // AppDIContainer.swift 개선
   import Foundation
   import DomainModule
   import DataModule
   import NetworkModule
   import AuthenticationModule
   
   final class AppDIContainer {
       // 코어 모듈 컨테이너들
       lazy var networkContainer: NetworkDIContainer = {
           return NetworkDIContainer()
       }()
       
       lazy var dataContainer: DataDIContainer = {
           return DataDIContainer(networkContainer: networkContainer)
       }()
       
       lazy var domainContainer: DomainDIContainer = {
           return DomainDIContainer(dataContainer: dataContainer)
       }()
       
       lazy var authContainer: AuthenticationDIContainer = {
           return AuthenticationDIContainer(networkContainer: networkContainer, dataContainer: dataContainer)
       }()
       
       // 기능 모듈 팩토리들
       func makeAccountModuleFactory() -> AccountModuleFactory {
           return AccountModuleFactory(domainContainer: domainContainer)
       }
       
       func makeAuthModuleFactory() -> AuthModuleFactory {
           return AuthModuleFactory(authContainer: authContainer)
       }
       
       // 추가 기능 모듈 팩토리들...
   }
   ```

2. **모듈 팩토리 구현/개선**
   - 각 기능 모듈별 팩토리 클래스 표준화
   - 의존성 주입 패턴 일관성 확보

3. **서비스 라이프사이클 관리**
   - 싱글톤 패턴 최소화 및 의존성 주입 활용
   - 메모리 관리 최적화

#### 6-7일차: 앱 라이프사이클 관리 코드 정리
1. **앱 이벤트 처리 통합**
   ```swift
   // ApplicationLifecycleManager.swift 구현
   import UIKit
   
   final class ApplicationLifecycleManager {
       private let notificationManager: NotificationManagerProtocol
       private let authManager: AuthManagerProtocol
       private let analyticsService: AnalyticsServiceProtocol
       
       init(notificationManager: NotificationManagerProtocol,
            authManager: AuthManagerProtocol,
            analyticsService: AnalyticsServiceProtocol) {
           self.notificationManager = notificationManager
           self.authManager = authManager
           self.analyticsService = analyticsService
           setupNotifications()
       }
       
       private func setupNotifications() {
           NotificationCenter.default.addObserver(self, 
                                                 selector: #selector(handleDidBecomeActive), 
                                                 name: UIApplication.didBecomeActiveNotification, 
                                                 object: nil)
           // 추가 앱 라이프사이클 알림 등록
       }
       
       @objc private func handleDidBecomeActive() {
           authManager.refreshTokenIfNeeded()
           notificationManager.refreshBadgeCount()
           analyticsService.trackEvent("app_became_active")
       }
       
       // 추가 라이프사이클 이벤트 핸들러...
   }
   ```

2. **앱 초기화 프로세스 최적화**
   - 비동기 초기화 작업 개선
   - 초기화 작업 우선순위 설정

3. **백그라운드 작업 관리**
   - 백그라운드 작업 등록 및 처리 개선
   - 백그라운드 세션 관리 최적화

### 2-2: Coordinator 패턴 재조정 (1주)

#### 8-10일차: SharedModule에서 Coordinator 사용 방식 표준화
1. **기본 Coordinator 프로토콜 개선**
   ```swift
   // Coordinator.swift 개선
   import UIKit
   
   public protocol Coordinator: AnyObject {
       var navigationController: UINavigationController { get }
       var childCoordinators: [Coordinator] { get set }
       
       func start()
       func finish()
       func coordinate(to coordinator: Coordinator)
   }
   
   public extension Coordinator {
       func coordinate(to coordinator: Coordinator) {
           childCoordinators.append(coordinator)
           coordinator.start()
       }
       
       func finish() {
           childCoordinators.forEach { $0.finish() }
           childCoordinators.removeAll()
       }
   }
   ```

2. **모듈별 Coordinator 구현 표준화**
   - 각 기능 모듈의 Coordinator 구현 검토 및 개선
   - Coordinator 간 통신 방식 표준화

3. **화면 전환 로직 일관성 확보**
   - 네비게이션 스택 관리 방식 통일
   - 모달 표시 및 해제 패턴 표준화

#### 11-12일차: Presentation Layer의 일부로 문서화 및 인식
1. **Coordinator 문서화**
   ```markdown
   # Coordinator 패턴 가이드
   
   ## 개요
   Coordinator는 Presentation Layer의 핵심 컴포넌트로, 화면 전환 및 네비게이션 흐름을 담당합니다.
   View와 ViewModel은 비즈니스 로직과 UI 표시에 집중하고, 화면 전환은 Coordinator가 담당합니다.
   
   ## 구현 원칙
   1. Coordinator는 다른 Coordinator를 자식으로 가질 수 있습니다.
   2. 각 기능 모듈은 자체 Coordinator를 가져야 합니다.
   3. Coordinator는 ViewModel과 통신하며, ViewModel은 Coordinator Protocol을 통해 화면 전환을 요청합니다.
   
   ## 사용 예시
   ```swift
   // 코드 예시
   ```
   
   ## 흐름도
   [Coordinator 흐름도 다이어그램]
   ```

2. **샘플 코드 작성**
   - 모범 사례를 보여주는 예제 Coordinator 구현
   - 문서에 포함할 다이어그램 작성

3. **개발자 교육 자료 준비**
   - Coordinator 패턴 사용 가이드라인 작성
   - 팀 공유 세션 준비

#### 13-14일차: 네비게이션 흐름 최적화
1. **딥링크 처리 개선**
   ```swift
   // DeepLinkHandler.swift 구현
   import Foundation
   
   enum DeepLinkType {
       case account(id: String)
       case transfer
       case notification(id: String?)
       case settings
       // 추가 딥링크 타입...
   }
   
   protocol DeepLinkHandlerProtocol {
       func handle(_ deepLink: DeepLinkType)
   }
   
   final class DeepLinkHandler: DeepLinkHandlerProtocol {
       private let appCoordinator: AppCoordinator
       
       init(appCoordinator: AppCoordinator) {
           self.appCoordinator = appCoordinator
       }
       
       func handle(_ deepLink: DeepLinkType) {
           switch deepLink {
           case .account(let id):
               appCoordinator.navigateToAccount(id: id)
           case .transfer:
               appCoordinator.navigateToTransfer()
           // 추가 케이스 처리...
           }
       }
   }
   ```

2. **화면 전환 애니메이션 최적화**
   - 사용자 경험을 개선하는 전환 애니메이션 구현
   - 화면 전환 시 데이터 전달 방식 개선

3. **백버튼 및 뒤로가기 처리 표준화**
   - 사용자 지정 백버튼 처리 로직 개선
   - 뒤로가기 동작 시 리소스 정리 로직 표준화

## 2단계 산출물 체크리스트

- [ ] 앱 진입점 코드 정리 및 최적화 완료
- [ ] 의존성 주입 아키텍처 개선 완료
- [ ] 앱 라이프사이클 관리 코드 표준화 완료
- [ ] Coordinator 패턴 구현 표준화 완료
- [ ] Coordinator 패턴 문서화 및 예제 코드 작성 완료
- [ ] 네비게이션 흐름 및 딥링크 처리 최적화 완료
- [ ] 2단계 완료 보고서 및 3단계 세부 계획

이 2단계 실행 계획을 통해 앱의 핵심 아키텍처 구조를 재정립하고, 앱 진입점과 화면 전환 로직을 명확하게 개선할 수 있습니다. 이는 향후 기능 모듈 리팩터링의 기반이 될 것입니다.
